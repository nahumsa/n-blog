<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on n-blog</title><link>https://nahumsa.github.io/n-blog/post/</link><description>Recent content in Posts on n-blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 11 May 2021 18:00:00 +0000</lastBuildDate><atom:link href="https://nahumsa.github.io/n-blog/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Quantum Simulation using qiskit's opflow</title><link>https://nahumsa.github.io/n-blog/2021-05-11-quantum_simulation/</link><pubDate>Tue, 11 May 2021 18:00:00 +0000</pubDate><guid>https://nahumsa.github.io/n-blog/2021-05-11-quantum_simulation/</guid><description>Quantum Simulation Theory We are concerned to find the solution of the Schrodinger Equation : $i \frac{d |\psi \rangle}{dt} = H | \psi \rangle$, which for a time-independent $H$ the solution is:
$$ | \psi (t) \rangle = e^{- i H t} | \psi (0) \rangle $$
H is extremely hard to exponentiate, thus we need to find an approximate solution. A good start is to use a first-order approximation $|\psi(t + \Delta t \rangle \approx (I - iH \Delta t) | \psi (0) \rangle$, which is easier to do than exponentiating, therefore we can approximate $(I - i H \Delta t)$ using quantum gates.</description></item><item><title>Meta-Variational Quantum Eigensolver</title><link>https://nahumsa.github.io/n-blog/2021-03-16-meta-vqe/</link><pubDate>Tue, 16 Mar 2021 20:00:00 +0000</pubDate><guid>https://nahumsa.github.io/n-blog/2021-03-16-meta-vqe/</guid><description>1) Meta-VQE The Meta-VQE algorithm is a variational quantum algorithm that is suited for NISQ devices and encodes parameters of a Hamiltonian into a variational ansatz which we can obtain good estimations of the ground state of the Hamiltonian by changing only those encoded parameters.
This leads to a advantage when compared with the original VQE algorithm, because if you want to know the profile of a parametrized Hamiltonian you would need to run the VQE algorithm for each parameter, using Meta-VQE you would only need to run for a fixed set of training parameters and in order to get the profile you would only need to change the parameters of the ansatz.</description></item><item><title>Variational Quantum Classifier</title><link>https://nahumsa.github.io/n-blog/2021-02-22-vqc/</link><pubDate>Mon, 22 Feb 2021 12:00:00 +0000</pubDate><guid>https://nahumsa.github.io/n-blog/2021-02-22-vqc/</guid><description>1) Introduction There are several applications for quantum computers, one of the most promising applications is Quantum Machine Learning.
Quantum Machine Learning is a novel field which aims to use Quantum Computer to do machine learning tasks, just as the name states. One of such tasks is the classification problem, where we aim to split the data into different classes. One example of a classification problem is when it is needed to classify if an email is a spam or not, the data would be the email content and we would train examples of spam mails and not spam mails in order to create a model of what a spam mail is and then use this model for novel data to solve our task.</description></item><item><title>Creating a Continous Integration pipeline using Github Actions</title><link>https://nahumsa.github.io/n-blog/2021-01-21-ci-github-actions/</link><pubDate>Thu, 21 Jan 2021 10:00:00 +0000</pubDate><guid>https://nahumsa.github.io/n-blog/2021-01-21-ci-github-actions/</guid><description>1) Introduction Continous Integration (CI) is the practice of automation the integration of code changes into a single software project. This is a good practive because when the code changes, it builds the application and runs tests to see if the changes in the code doesn&amp;rsquo;t break anything. This method of development is linked directly with Continous Deployment (CD) which is a an automation of deployment of your application
Besides being a good thing to have all changes in the code being verified if it breaks something in the code, this is a key feature for agile development because the development process becomes more transparent, mainly if the team is using a Test-Driven Development approach.</description></item><item><title>Creating a simple Neural Network in JAX</title><link>https://nahumsa.github.io/n-blog/2020-09-25-nn-jax/</link><pubDate>Fri, 25 Sep 2020 10:00:00 +0000</pubDate><guid>https://nahumsa.github.io/n-blog/2020-09-25-nn-jax/</guid><description>Creating a neural network in JAX JAX is a new python library that offers autograd and XLA, leading to high-performance machine learning, and numeric research. JAX works just as numpy and using jit (just in time) compilation, you can have high-performance without going to low level languages. One awesome thing is that, just as tensorflow, you can use GPUs and TPUs for acceleration.
In this post my aim is to build and train a simple Convolutional Neural Network using JAX.</description></item><item><title>Changing gates on a predifined circuit (Qiskit)</title><link>https://nahumsa.github.io/n-blog/2020-09-08-changing-circuits/</link><pubDate>Tue, 08 Sep 2020 20:00:00 +0000</pubDate><guid>https://nahumsa.github.io/n-blog/2020-09-08-changing-circuits/</guid><description>Changing gates on a predefined circuit in Qiskit This notebook was inpired by a the paper by Czarnik et al. - Error mitigation with Clifford quantum-circuit data. Where you convert your arbitrary circuit into a clifford circuit that is simulable classically, a technique known as Clifford Data Regression (CDR).
So I was searching for to change a pre-existing circuit and I did not found any proper tutorial to do this on qiskit, even though it is simple, it is nontrivial and you need to change some inner objects inside the QuantumCircuit.</description></item><item><title>Monte Carlo Integration</title><link>https://nahumsa.github.io/n-blog/2020-07-25-mc-integration/</link><pubDate>Sat, 25 Jul 2020 17:00:00 +0000</pubDate><guid>https://nahumsa.github.io/n-blog/2020-07-25-mc-integration/</guid><description>1) Introduction In this blog post I will explain how to integrate an arbitrary function using Monte Carlo Integration basically we are shooting darts into a dartboard and accepting them according to a given criteria, we can represent this by the following gif:
2) Algorithm In Monte Carlo Integration we sample from an interval ${a,b}$ and see if it is inside the region between the function and the x axis, if this condition is satisfied we accept the sample, otherwise we discart the sample.</description></item><item><title>Grover Algorithm</title><link>https://nahumsa.github.io/n-blog/2020-07-04-grover/</link><pubDate>Sat, 04 Jul 2020 18:00:00 +0000</pubDate><guid>https://nahumsa.github.io/n-blog/2020-07-04-grover/</guid><description>1) Introduction Grover&amp;rsquo;s algorithm is useful for searching an unstructured database with N elements. For instance,you have a phone number and want to find the corresponding name associated to this phone number, since it is unstructured you need to check every element (in the worst case scenario), but if you have the solution it is easy to check, this shows that the problem is NP.
In order to show Grover&amp;rsquo;s algorithm we need to rephrase as an oracle problem: Labelling each element of the database ${0,1, \dots, N-1 }$ and $x_0$ the unknown marked item.</description></item><item><title>Elementary Cellular Automaton</title><link>https://nahumsa.github.io/n-blog/2020-06-26-cellular-automaton/</link><pubDate>Fri, 26 Jun 2020 11:00:00 +0000</pubDate><guid>https://nahumsa.github.io/n-blog/2020-06-26-cellular-automaton/</guid><description>1) Introduction Cellular Automaton is a discrete model that can create complex behaviors by using simple rules. The cellular automaton is constructed on a grid with a finite number of states with a deterministic rule for evolution, the surprising fact is that by using a deterministic rule there can be complex behavior that we could not foreseen just by looking on the rule. This model was developed by remarkable people such as Von Neumann, Ulam, Bariccelli.</description></item><item><title>Quantum State Tomography</title><link>https://nahumsa.github.io/n-blog/2020-06-22-tomography/</link><pubDate>Mon, 22 Jun 2020 08:00:00 +0000</pubDate><guid>https://nahumsa.github.io/n-blog/2020-06-22-tomography/</guid><description>1) Introduction Let&amp;rsquo;s try to do the tomography of a given one-qubit quantum state just to understand the principle behind this procedure:
$$ \rho = \begin{pmatrix} \rho_{11} &amp;amp; \rho_{12} \\
\rho_{21} &amp;amp; \rho_{22} \end{pmatrix} = \frac{1}{2} \sum_{i=0}^3 S_i \sigma_i $$
Where $\rho_{11} + \rho_{22} = 1$, $\rho_{12} = \rho_{21}^*$, and $\sigma_i$ are the pauli matrices.
$$ \sigma_0 = I \ \ \ \sigma_1 = \sigma_x = \begin{pmatrix} 0 &amp;amp; 1 \\ 1 &amp;amp; 0 \end{pmatrix} \ \ \ \sigma_2 = \sigma_y = \begin{pmatrix} 0 &amp;amp; i \\ -i &amp;amp; 0 \end{pmatrix} \ \ \ \sigma_3 = \sigma_z = \begin{pmatrix} 1 &amp;amp; 0 \\ 0 &amp;amp; -1 \end{pmatrix} $$</description></item><item><title>Deutsch Algorithm</title><link>https://nahumsa.github.io/n-blog/2020-06-18-deutsch/</link><pubDate>Thu, 18 Jun 2020 13:00:00 +0000</pubDate><guid>https://nahumsa.github.io/n-blog/2020-06-18-deutsch/</guid><description>1) Introduction The Deutsch algorithm is idealized to be easy for a quantum computer with a oracle and hard for a classical deterministic computer. Therefore, it is not directly applicable to a defined problem and works more like a proof that Quantum Computers could be faster than a Classical Computer.
This algorithm is later generalized for a function with more inputs, which is called the Deutsch-Josza Algorithm, which proves an exponential speedup relative to a classical deterministic computer, it is important to note that this doesn&amp;rsquo;t prove an exponential speedup comparing to a Probabilistic Classical Computer.</description></item><item><title>Introduction to IBM Qiskit</title><link>https://nahumsa.github.io/n-blog/2020-06-08-introduction-qiskit/</link><pubDate>Tue, 09 Jun 2020 19:00:00 +0000</pubDate><guid>https://nahumsa.github.io/n-blog/2020-06-08-introduction-qiskit/</guid><description>First steps into Quantum Computing %matplotlib inline import qiskit as qsk import numpy as np import matplotlib.pyplot as plt 1) Introduction Qiskit is an open-source library for quantum computing developed by IBM, you can register for free on IBMQ and get access to real quantum computers.
In this post I will introduce some important functions to use IBM qiskit, this will be done by an example of constructing an entangled state, which is a important state in quantum mechanics.</description></item></channel></rss>