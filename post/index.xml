<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on n-blog</title><link>https://nahumsa.github.io/n-blog/post/</link><description>Recent content in Posts on n-blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 21 Jan 2021 10:00:00 +0000</lastBuildDate><atom:link href="https://nahumsa.github.io/n-blog/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Creating a Continous Integration pipeline using Github Actions</title><link>https://nahumsa.github.io/n-blog/2021-01-21-ci-github-actions/</link><pubDate>Thu, 21 Jan 2021 10:00:00 +0000</pubDate><guid>https://nahumsa.github.io/n-blog/2021-01-21-ci-github-actions/</guid><description>1) Introduction Continous Integration (CI) is the practice of automation the integration of code changes into a single software project. This is a good practive because when the code changes, it builds the application and runs tests to see if the changes in the code doesn&amp;rsquo;t break anything. This method of development is linked directly with Continous Deployment (CD) which is a an automation of deployment of your application
Besides being a good thing to have all changes in the code being verified if it breaks something in the code, this is a key feature for agile development because the development process becomes more transparent, mainly if the team is using a Test-Driven Development approach.</description></item><item><title>Creating a simple Neural Network in JAX</title><link>https://nahumsa.github.io/n-blog/2020-09-25-nn-jax/</link><pubDate>Fri, 25 Sep 2020 10:00:00 +0000</pubDate><guid>https://nahumsa.github.io/n-blog/2020-09-25-nn-jax/</guid><description>Creating a neural network in JAX JAX is a new python library that offers autograd and XLA, leading to high-performance machine learning, and numeric research. JAX works just as numpy and using jit (just in time) compilation, you can have high-performance without going to low level languages. One awesome thing is that, just as tensorflow, you can use GPUs and TPUs for acceleration.
In this post my aim is to build and train a simple Convolutional Neural Network using JAX.</description></item><item><title>Changing gates on a predifined circuit (Qiskit)</title><link>https://nahumsa.github.io/n-blog/2020-09-08-changing-circuits/</link><pubDate>Tue, 08 Sep 2020 20:00:00 +0000</pubDate><guid>https://nahumsa.github.io/n-blog/2020-09-08-changing-circuits/</guid><description>Changing gates on a predefined circuit in Qiskit This notebook was inpired by a the paper by Czarnik et al. - Error mitigation with Clifford quantum-circuit data. Where you convert your arbitrary circuit into a clifford circuit that is simulable classically, a technique known as Clifford Data Regression (CDR).
So I was searching for to change a pre-existing circuit and I did not found any proper tutorial to do this on qiskit, even though it is simple, it is nontrivial and you need to change some inner objects inside the QuantumCircuit.</description></item><item><title>Monte Carlo Integration</title><link>https://nahumsa.github.io/n-blog/2020-07-25-mc-integration/</link><pubDate>Sat, 25 Jul 2020 17:00:00 +0000</pubDate><guid>https://nahumsa.github.io/n-blog/2020-07-25-mc-integration/</guid><description>1) Introduction In this blog post I will explain how to integrate an arbitrary function using Monte Carlo Integration basically we are shooting darts into a dartboard and accepting them according to a given criteria, we can represent this by the following gif:
2) Algorithm In Monte Carlo Integration we sample from an interval ${a,b}$ and see if it is inside the region between the function and the x axis, if this condition is satisfied we accept the sample, otherwise we discart the sample.</description></item><item><title>Grover Algorithm</title><link>https://nahumsa.github.io/n-blog/2020-07-04-grover/</link><pubDate>Sat, 04 Jul 2020 18:00:00 +0000</pubDate><guid>https://nahumsa.github.io/n-blog/2020-07-04-grover/</guid><description>1) Introduction Grover&amp;rsquo;s algorithm is useful for searching an unstructured database with N elements. For instance,you have a phone number and want to find the corresponding name associated to this phone number, since it is unstructured you need to check every element (in the worst case scenario), but if you have the solution it is easy to check, this shows that the problem is NP.
In order to show Grover&amp;rsquo;s algorithm we need to rephrase as an oracle problem: Labelling each element of the database ${0,1, \dots, N-1 }$ and $x_0$ the unknown marked item.</description></item><item><title>Elementary Cellular Automaton</title><link>https://nahumsa.github.io/n-blog/2020-06-26-cellular-automaton/</link><pubDate>Fri, 26 Jun 2020 11:00:00 +0000</pubDate><guid>https://nahumsa.github.io/n-blog/2020-06-26-cellular-automaton/</guid><description>1) Introduction Cellular Automaton is a discrete model that can create complex behaviors by using simple rules. The cellular automaton is constructed on a grid with a finite number of states with a deterministic rule for evolution, the surprising fact is that by using a deterministic rule there can be complex behavior that we could not foreseen just by looking on the rule. This model was developed by remarkable people such as Von Neumann, Ulam, Bariccelli.</description></item><item><title>Quantum State Tomography</title><link>https://nahumsa.github.io/n-blog/2020-06-22-tomography/</link><pubDate>Mon, 22 Jun 2020 08:00:00 +0000</pubDate><guid>https://nahumsa.github.io/n-blog/2020-06-22-tomography/</guid><description>1) Introduction Let&amp;rsquo;s try to do the tomography of a given one-qubit quantum state just to understand the principle behind this procedure:
$$ \rho = \begin{pmatrix} \rho_{11} &amp;amp; \rho_{12} \\
\rho_{21} &amp;amp; \rho_{22} \end{pmatrix} = \frac{1}{2} \sum_{i=0}^3 S_i \sigma_i $$
Where $\rho_{11} + \rho_{22} = 1$, $\rho_{12} = \rho_{21}^*$, and $\sigma_i$ are the pauli matrices.
$$ \sigma_0 = I \ \ \ \sigma_1 = \sigma_x = \begin{pmatrix} 0 &amp;amp; 1 \\ 1 &amp;amp; 0 \end{pmatrix} \ \ \ \sigma_2 = \sigma_y = \begin{pmatrix} 0 &amp;amp; i \\ -i &amp;amp; 0 \end{pmatrix} \ \ \ \sigma_3 = \sigma_z = \begin{pmatrix} 1 &amp;amp; 0 \\ 0 &amp;amp; -1 \end{pmatrix} $$</description></item><item><title>Deutsch Algorithm</title><link>https://nahumsa.github.io/n-blog/2020-06-18-deutsch/</link><pubDate>Thu, 18 Jun 2020 13:00:00 +0000</pubDate><guid>https://nahumsa.github.io/n-blog/2020-06-18-deutsch/</guid><description>1) Introduction The Deutsch algorithm is idealized to be easy for a quantum computer with a oracle and hard for a classical deterministic computer. Therefore, it is not directly applicable to a defined problem and works more like a proof that Quantum Computers could be faster than a Classical Computer.
This algorithm is later generalized for a function with more inputs, which is called the Deutsch-Josza Algorithm, which proves an exponential speedup relative to a classical deterministic computer, it is important to note that this doesn&amp;rsquo;t prove an exponential speedup comparing to a Probabilistic Classical Computer.</description></item><item><title>Introduction to IBM Qiskit</title><link>https://nahumsa.github.io/n-blog/2020-06-08-introduction-qiskit/</link><pubDate>Tue, 09 Jun 2020 19:00:00 +0000</pubDate><guid>https://nahumsa.github.io/n-blog/2020-06-08-introduction-qiskit/</guid><description>First steps into Quantum Computing %matplotlib inline import qiskit as qsk import numpy as np import matplotlib.pyplot as plt 1) Introduction Qiskit is an open-source library for quantum computing developed by IBM, you can register for free on IBMQ and get access to real quantum computers.
In this post I will introduce some important functions to use IBM qiskit, this will be done by an example of constructing an entangled state, which is a important state in quantum mechanics.</description></item></channel></rss>