<!doctype html><html prefix="og: http://ogp.me/ns#"><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Grover Algorithm</title><meta name=description content="1) Introduction Grover&rsquo;s algorithm is useful for searching an unstructured database with N elements. For instance,you have a phone number and want to find the corresponding name associated to this phone number, since it is unstructured you need to check every element (in the worst case scenario), but if you have the solution it is easy to check, this shows that the problem is NP.
In order to show Grover&rsquo;s algorithm we need to rephrase as an oracle problem: Labelling each element of the database ${0,1, \dots, N-1 }$ and $x_0$ the unknown marked item."><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=generator content="Hugo 0.80.0"><meta name=robots content="index,follow"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="Grover Algorithm"><meta property="og:description" content="1) Introduction Grover&rsquo;s algorithm is useful for searching an unstructured database with N elements. For instance,you have a phone number and want to find the corresponding name associated to this phone number, since it is unstructured you need to check every element (in the worst case scenario), but if you have the solution it is easy to check, this shows that the problem is NP.
In order to show Grover&rsquo;s algorithm we need to rephrase as an oracle problem: Labelling each element of the database ${0,1, \dots, N-1 }$ and $x_0$ the unknown marked item."><meta property="og:type" content="article"><meta property="og:url" content="https://nahumsa.github.io/n-blog/2020-07-04-grover/"><link rel=stylesheet href=https://nahumsa.github.io/n-blog/dist/site.css><link rel=stylesheet href=https://nahumsa.github.io/n-blog/dist/syntax.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,400,600,700,300&subset=latin,cyrillic-ext,latin-ext,cyrillic"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:true,processEnvironments:true},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}};window.addEventListener('load',(event)=>{document.querySelectorAll("mjx-container").forEach(function(x){x.parentElement.classList+='has-jax'})});</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-170504520-1','auto');ga('send','pageview');}</script><div id=wrapper><header class=site-header><div class=container><div class=site-title-wrapper><h1 class=site-title><a href=https://nahumsa.github.io/n-blog/>n-blog</a></h1><a class="button-square button-social hint--top" data-hint=Twitter aria-label=Twitter href=https://twitter.com/sa_nahum rel=me><i class="fa fa-twitter" aria-hidden=true></i></a><a class="button-square button-social hint--top" data-hint=Github aria-label=Github href=https://github.com/nahumsa rel=me><i class="fa fa-github-alt" aria-hidden=true></i></a><a class="button-square button-social hint--top" data-hint=Email aria-label="Send an Email" href=mailto:nahumsa@cbpf.br><i class="fa fa-envelope" aria-hidden=true></i></a></div><ul class=site-nav></ul></div></header><div id=container><div class=container><article class=post-container itemscope itemtype=http://schema.org/BlogPosting><header class=post-header><h1 class=post-title itemprop="name headline">Grover Algorithm</h1><p class="post-date post-line"><span>Published <time datetime=2020-07-04 itemprop=datePublished>Sat, Jul 4, 2020</time></span>
<span>by</span>
<span itemscope itemprop=author itemtype=https://schema.org/Person><span itemprop=name><a href=# itemprop=url rel=author>Nahum SÃ¡</a></span></span></p></header><div class="post-content clearfix" itemprop=articleBody><h1 id=1-introduction>1) Introduction</h1><p>Grover&rsquo;s algorithm is useful for searching an unstructured database with N elements. For instance,you have a phone number and want to find the corresponding name associated to this phone number, since it is unstructured you need to check every element (in the worst case scenario), but if you have the solution it is easy to check, this shows that the problem is NP.</p><p>In order to show Grover&rsquo;s algorithm we need to rephrase as an oracle problem: Labelling each element of the database ${0,1, \dots, N-1 }$ and $x_0$ the unknown marked item. The oracle $f$ computes the following binary function:</p><p>$$
f: {0,1 }^N \rightarrow {0,1 } \hspace{1em} , \hspace{1em} \mathrm{with} \hspace{2em} f(x) = \begin{cases}
1, & \text{if } x=x_0 \\<br>0, & \text{otherwise}
\end{cases}
$$</p><p>For a classical computer, the probability to find $x_0$ is $\frac{1}{N}$ , so to find $x_0$ with probability $p$ is needed $p N = \mathcal{O}(N)$ oracle queries. Grovers showed that on a quantum computer we can have a quadratic speedup, then we will need $\mathcal{O}(\sqrt{N})$ queries. This is not massive, but we can compare this speedup with the breakthrough that Fast Fourier Transform(FFT) did for signalling processing.</p><h1 id=2-general-algorithm>2) General Algorithm</h1><h2 id=21-algorithm>2.1) Algorithm</h2><p>Here we suppose a quantum oracle with the ability to recognize solutions to the search problem. This recognition is signaled by making use of an oracle qubit. More precisely:</p><p>$$
| x \rangle | q \rangle \xrightarrow[]{O} | x \rangle | q \oplus f(x) \rangle
$$</p><p>The oracle $| q \rangle$ is a single qubit which is flipped if $f(x) = 1$ and is unchanged otherwise. We can check if whether x is a solution by preparing $| x \rangle| 0 \rangle$ and seeing if the oracle qubit flips when using the oracle.</p><p>It is common to use
$| q \rangle = \frac{1}{\sqrt{2}} \big( | 0 \rangle - | 1 \rangle \big)$. The action of the oracle is:</p><p>$$
| x \rangle \frac{1}{\sqrt{2}} \big( | 0 \rangle - | 1 \rangle \big) \xrightarrow[]{O} (-1)^{f(x)} | x \rangle \frac{1}{\sqrt{2}} \big( | 0 \rangle - | 1 \rangle \big)
$$</p><p>Using this type of oracle qubit it remains the same when applying the oracle and can be omitted from the following steps of the algorithm. With this convention:</p><p>$$
| x \rangle \xrightarrow[]{O} (-1)^{f(x)}| x \rangle
$$</p><p>The oracle marks the solution by shifting the phase. For a N item search problem with M solutions, we need to apply the search oracle $O(\sqrt{\frac{N}{M}})$ times in order to obtain the solution.</p><p>The algorithm with the Grover operator G is the following:</p><p><img src=/n-blog/figures/2020-07-04-Grover_files/GroverCircuit.jpg alt="Grover Circuit">
Figure 1: Circuit for the Grover Algorithm, the unitary G are called Grover Iterations or Grover Operator</p><p>The algorithm begins with $| 0 \rangle^{\otimes N}$. The Haddamard transform put in the equal superposition state, which we call $| \psi \rangle$:</p><p>$$
| \psi \rangle = \frac{1}{\sqrt{N}} \sum_{x=0}^{N-1} | x \rangle
$$</p><p>The algorithm consists of repeated applications of the grover operator G. This subroutine can be broken up into 4 steps:</p><p>(1): Apply the oracle O.</p><p>(2): Apply the Haddamard transform $H^{\otimes N}$.</p><p>(3): Perform a conditional phase shift on the computer, with every computational basis state except
$| 0 \rangle$
receiving a phase shift of -1:
$| x \rangle \xrightarrow[]{M} -(-1)^{\delta_{x0}} | x \rangle$
.</p><p>(4): Apply the Haddamard transform $H^{\otimes N}$.</p><p>The circuit for the Grover operator is the following:</p><p><img src=/n-blog/figures/2020-07-04-Grover_files/GroverOperator.jpg alt="Grover Operator">
Figure 2: Circuit for the Grover Operator G.</p><p>This operator for the conditional phase shift on step (2) is simply $M = 2 | 0 \rangle \langle 0 | - I$, because we have:</p><p>$$
M = \begin{pmatrix}
2-1 & 0 & \dots & 0 \\<br>0 & -1 & \dots & 0 \\<br>\vdots & \ddots & \vdots & \vdots \\<br>0 & \dots & 0 & -1
\end{pmatrix}
$$</p><p>Steps 2 and 4 needs $n=\log(N)$ operations each. Step 3, the conditional phase shift, can be implemented using $O(n)$ gates. But the cost of the Oracle depends on the application, on the bright side, we only need to call the oracle once. The steps 2,3,4 combined are:</p><p>$$
H^{\otimes n} \big( 2 | 0 \rangle \langle 0 | - I \big) H^{\otimes n} = 2 | \psi \rangle \langle \psi |
$$</p><p>Where $| \psi \rangle$ is the weighted superposition. Thus: $G = \big( 2| \psi \rangle \langle \psi | - I \big) O $. Let&rsquo;s see how the operator $ 2| \psi \rangle \langle \psi | - I $ acts on an arbitrary state $| \eta \rangle = \sum_k \alpha_k | k \rangle $:</p><p>$$
\begin{split}
\bigg( 2| \psi \rangle \langle \psi | - I \bigg) | \eta \rangle & = \bigg( 2| \psi \rangle \langle \psi | - I \bigg) \sum_k \alpha_k |k \rangle \\<br>& = \bigg[ \frac{2}{N} \sum_{x,y} | x \rangle \langle y | - I \bigg] \sum_k \alpha_k |k \rangle = \frac{2}{N} \sum_{x,y,k} \alpha_k | x \rangle \langle y | | k \rangle - \sum_k \alpha_k | k \rangle \\<br>& = \frac{2}{N} \sum_{x,k} \alpha_k | x \rangle - | \eta \rangle = 2 \overbrace{\sum_{k} \frac{\alpha_k}{N}}^{\equiv \langle \alpha \rangle} \sum_x | x \rangle - | \eta \rangle \\<br>& = 2 \sum_x \langle \alpha \rangle | x \rangle - \sum_k \alpha_k | k \rangle = \sum_k \bigg[ - \alpha_k + 2 \langle \alpha \rangle \bigg] | k \rangle
\end{split}<br>$$</p><p>For this reason, sometimes this operator is called the inversion about the mean.</p><h2 id=22-geometric-representation>2.2) Geometric Representation</h2><p>We can have a geometric visualization of the algorithm that will help us to show that the algorithm needs $O(\sqrt{N})$ gates, for this we want to show that the Grover Operator can be regarded as a rotation in the 2D space spanned by the starting vector
$|\psi \rangle$
and the state with the uniform superposition of solutions to the search problem. We adopt the convention $\sum_x^{'}$ to be the sum over all x which are solutions to the search problem, and $\sum_x''$ to be the sum over all x which are not solutions. We also define the normalized states:</p><p>$$
| \alpha \rangle \equiv \frac{1}{\sqrt{N-M}} \sum_x '' |x \rangle \ \ \ \ | \beta \rangle \equiv \frac{1}{\sqrt{M}} \sum_x ' | x \rangle
$$</p><p>We can rewrite $| \psi \rangle$ in terms of $| \alpha \rangle$ and $ | \beta \rangle$:</p><p>$$
\begin{split}
| \psi \rangle & = \frac{1}{\sqrt{N}} \sum_x | x \rangle = \frac{1}{\sqrt{N}} \bigg( \sum_x ' | x \rangle + \sum_x '' | x \rangle \bigg) \\<br>& = \frac{1}{\sqrt{N}} \bigg( \sqrt{M} | \beta \rangle + \sqrt{N-M} | \alpha \rangle \bigg) \\<br>& = \sqrt{\frac{N-M}{N}} | \alpha \rangle + \sqrt{\frac{M}{N}} | \beta \rangle
\end{split}
$$</p><p>So that the initial state is spanned by $| \alpha \rangle$ and $| \beta \rangle$ . The effect of G can be understood in a beautiful way by showing that the oracle $O$ performs a reflection about the vector $| \alpha \rangle$ and $| \beta \rangle$. That is:</p><p>$$
O ( a |\alpha \rangle + b | \beta \rangle) = a | \alpha \rangle - b | \beta \rangle
$$</p><p>Similarly,
$2 |\psi \rangle \langle \psi | - I$
also performs a reflection in the plane about the vector
$|\psi \rangle$
. The product of two reflections is a rotation!</p><p>Thus $G^k| \psi \rangle$ remains in the space spanned by $|\alpha \rangle$ and $|\beta \rangle$.
Let $\cos \big( \frac{\theta}{2} \big) = \sqrt{\frac{N- M}{N}}$ , so that $|\psi \rangle = \cos \frac{\theta}{2} |\alpha \rangle + \sin \frac{\theta}{2} |\beta\rangle$ . Let&rsquo;s see what happens on a grover iteration:</p><p><img src=/n-blog/figures/2020-07-04-Grover_files/Grover.jpg alt=Geometric>
Figure 3: Geometric representation of the Grover Iteration</p><p>We see from the figure that:</p><p>$$
G | \psi \rangle = \cos \frac{3 \theta}{2} | \alpha \rangle + \sin \frac{3 \theta}{2} | \beta \rangle
$$</p><p>So the rotation is equal to $\theta$. It follows that after k iterations of G, we have:</p><p>$$
G^k | \psi \rangle = \cos \bigg( \frac{2k + 1}{2} \theta \bigg) | \alpha \rangle + \sin \bigg( \frac{2k + 1}{2} \theta \bigg) | \beta \rangle
$$</p><p>Thus, in the ${ | \alpha \rangle, | \beta \rangle }$ basis, we can write the Grover iteration as:</p><p>$$
G = \begin{bmatrix}
\cos \theta & - \sin \theta \\<br>\sin \theta & \cos \theta
\end{bmatrix}
$$</p><p>Where $\theta \in [0, \frac{\pi}{2}]$ and $\sin \theta = \sin \bigg( \frac{\theta}{2} + \frac{\theta}{2} \bigg) = 2 \sin \frac{\theta}{2} \cos \frac{\theta}{2} \Rightarrow \sin \theta = 2 \frac{\sqrt{M(N-M)}}{N}$.</p><p>In conclusion, the grover iteration acts as a rotation towards $| \beta \rangle$ in the space spanned by ${ | \alpha \rangle, | \beta \rangle }$, so repeated applications of G are required for us to measure $| \beta \rangle$ with high probability.</p><h2 id=23-performance-of-the-algorithm>2.3) Performance of the Algorithm</h2><p>How many times we need to repeat the Grover operator in order to rotate
$|\psi \rangle$
near
$| \beta \rangle$
?</p><p>The initial system starts with
$|\psi \rangle = \sqrt{\frac{N-M}{N}} | \alpha \rangle + \sqrt{\frac{M}{N}} | \beta \rangle$
, so rotating through $\arccos \sqrt{\frac{M}{N}}$ radians takes the system to
$| \beta \rangle$
. Let denote the closest integer to the real number $x$ as $\mathrm{CI}(x)$, where we round halves down. Then repeating the grover iteration $ R = \mathrm{CI}\bigg( \frac{\arccos \sqrt{\frac{M}{N}}}{\theta} \bigg)$ times rotates
$|\psi \rangle$
within an angle $\frac{\theta}{2} \leq \frac{\pi}{4}$ of
$| \beta \rangle$
.</p><p>Observation of the state in the computational basis then yields a solution to the search problem with a probability at least $\frac{1}{2}$. For specific values of M and N it is possible to achieve higher probability of success. For example, if $M &#171; N$, we have that $\sin \theta \approx \theta$, and thus the angular error in the final state is at most $\frac{\theta}{2} \approx \sqrt{\frac{M}{N}}$, giving probability of at most $\frac{M}{N}$.</p><p>The form of R is an exact expression for the query complexity of the search algorithm, but we can have a simpler expression that summarizes the essential behaviour of R. Note that $R \leq \lceil \frac{\pi}{2 \theta} \rceil$, because $\arccos \sqrt{\frac{M}{N} \leq \frac{\pi}{2}}$, so we can give an upper bound on R. Firstly we assume $M \leq \frac{N}{2}$, thus $\frac{\theta}{2} \geq \sin \frac{\theta}{2} = \sqrt{\frac{M}{N}}$. Then we have a upper bound for R:</p><p>\begin{equation}
R \leq \bigg\lceil \frac{\pi}{4} \sqrt{\frac{
N}{M}} \ \bigg\rceil
\end{equation}</p><p>Thus, $R = O\big( \sqrt{\frac{N}{M}} \big)$ oracle calls must be performed in order to obtain a solution with high probability. We have a polynomial speed-up over the classical algorithm.</p><p>We only considered the case when $M &lt; \frac{N}{2}$, what happens if this is not the case? In this case the angle $\theta$ gets smaller and we need more interactions as M increases. But since we expect to be easy to find a solution ( because $M \geq \frac{N}{2}$ ) we can randomly pick a solution and check if it is a solution using the oracle. This succeeds with probability at least $\frac{1}{2}$, and requires only one query of the oracle, but only works if we know the number of solutions in advance.</p><p>If we don&rsquo;t know that $M \geq \frac{N}{2}$. We can double the number of elements in the search space by adding N extra items, none which are solutions. This is done by adding a single qubit
$| q \rangle$
to the search index, doubling the numbers of items to be searched to $2N$. A new augmented oracle $O'$ can be constructed in a way that marks an item only if it is a solution to the search problem and the extra bit is set to zero; The new search problem has only M solutions out of $2N$, so using $R = \frac{\pi}{4} \sqrt{\frac{2N}{M}}$ queries of $O'$ we get a solution of high probability, since we are using the Big-O notation we are ignoring constants that multiply the scaling and we have the same scaling $O \big( \sqrt{\frac{N}{M}} \big)$.</p><h1 id=3-example-for-n4>3) Example for N=4</h1><p>Here I will follow the <a href=https://qiskit.org/textbook/ch-algorithms/grover.html>Qiskit Book</a> and we will focus on the implementation for $N=4$, but the algorithm implementation is not hard to scale up for any $N$.</p><p>The first part of the algorithm is to build an oracle that marks the desired state, let&rsquo;s consider the marked up state $\left| 11 \right>$ .</p><p>Therefore, we need that the oracle acts as follows:</p><p>$$
O \left|s \right> = O \ \frac{1}{2} \ \bigg( \left| 00 \right> + \left| 01 \right> + \left| 10 \right> + \left| 11 \right> \bigg) = \frac{1}{2} \ \bigg( \left| 00 \right> + \left| 01 \right> + \left| 10 \right> - \left| 11 \right> \bigg)
$$</p><p>This is the same as a controled Z gate, that means if your first qubit is $\left| 1 \right>$, then you apply an Z operator on the seccond qubit:</p><p>$$
\mathrm{CZ} = \left| 0 \right> \left&lt; 0 \right| \otimes 1 + \left| 1 \right> \left&lt; 1 \right| \otimes Z
$$</p><p>This can be done by the reflection: $D = 2 \left| s \right> \left&lt; s \right| - 1$.</p><p>It can be shown that: $D = H^{2\otimes}D&rsquo;H^{2\otimes}$, where:</p><p>$$
D' = \begin{pmatrix}
1 & 0 & 0 & 0 \\<br>0 & -1 & 0 & 0 \\<br>0 & 0 & -1 & 0 \\<br>0 & 0 & 0 & -1
\end{pmatrix}
$$</p><p>Therefore:</p><p>$$
D' \left|s\right> = \frac{1}{2} \ \bigg( \left|00\right> - \left|01\right> - \left|10\right> - \left|11\right> \bigg)
$$</p><p>We know that the state
$\left| 00 \right>$
is the only one that changes the sign and we also know that we can change the sign of
$\left| 11 \right>$
by an CZ gate. The other signs can be changed using Z gates on each qubit, because
$Z \left| i\right> = (-1)^i \left|i \right>$
.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=o>%</span><span class=n>matplotlib</span> <span class=n>inline</span>
<span class=kn>import</span> <span class=nn>qiskit</span> <span class=kn>as</span> <span class=nn>Qsk</span>
<span class=kn>import</span> <span class=nn>numpy</span> <span class=kn>as</span> <span class=nn>np</span>
<span class=kn>import</span> <span class=nn>matplotlib.pyplot</span> <span class=kn>as</span> <span class=nn>plt</span>
</code></pre></div><h2 id=circuit>Circuit</h2><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>Q_Reg</span> <span class=o>=</span> <span class=n>Qsk</span><span class=o>.</span><span class=n>QuantumRegister</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
<span class=n>C_Reg</span> <span class=o>=</span> <span class=n>Qsk</span><span class=o>.</span><span class=n>ClassicalRegister</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
<span class=n>Q_Circuit</span> <span class=o>=</span> <span class=n>Qsk</span><span class=o>.</span><span class=n>QuantumCircuit</span><span class=p>(</span><span class=n>Q_Reg</span><span class=p>,</span><span class=n>C_Reg</span><span class=p>)</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=c1>#Grover</span>

<span class=n>Q_Circuit</span><span class=o>.</span><span class=n>h</span><span class=p>(</span><span class=n>Q_Reg</span><span class=p>);</span>
<span class=n>Q_Circuit</span><span class=o>.</span><span class=n>cz</span><span class=p>(</span><span class=n>Q_Reg</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span><span class=n>Q_Reg</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
<span class=n>Q_Circuit</span><span class=o>.</span><span class=n>h</span><span class=p>(</span><span class=n>Q_Reg</span><span class=p>);</span>
<span class=n>Q_Circuit</span><span class=o>.</span><span class=n>z</span><span class=p>(</span><span class=n>Q_Reg</span><span class=p>);</span>
<span class=n>Q_Circuit</span><span class=o>.</span><span class=n>cz</span><span class=p>(</span><span class=n>Q_Reg</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span><span class=n>Q_Reg</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
<span class=n>Q_Circuit</span><span class=o>.</span><span class=n>h</span><span class=p>(</span><span class=n>Q_Reg</span><span class=p>);</span>

<span class=c1>#Measurement</span>

<span class=n>Q_Circuit</span><span class=o>.</span><span class=n>barrier</span><span class=p>(</span><span class=n>Q_Reg</span><span class=p>);</span>
<span class=n>Q_Circuit</span><span class=o>.</span><span class=n>measure</span><span class=p>(</span><span class=n>Q_Reg</span><span class=p>,</span><span class=n>C_Reg</span><span class=p>);</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>Q_Circuit</span><span class=o>.</span><span class=n>draw</span><span class=p>(</span><span class=n>output</span><span class=o>=</span><span class=s1>&#39;mpl&#39;</span><span class=p>)</span>
</code></pre></div><p><img src=/n-blog/figures/2020-07-04-Grover_files/2020-07-04-Grover_16_0.svg alt=Circuit></p><h2 id=simulation>Simulation</h2><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>backend_sim</span> <span class=o>=</span> <span class=n>Qsk</span><span class=o>.</span><span class=n>Aer</span><span class=o>.</span><span class=n>get_backend</span><span class=p>(</span><span class=s1>&#39;qasm_simulator&#39;</span><span class=p>)</span>
<span class=n>job_sim</span> <span class=o>=</span> <span class=n>Qsk</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=n>Q_Circuit</span><span class=p>,</span> <span class=n>backend_sim</span><span class=p>,</span> <span class=n>shots</span><span class=o>=</span><span class=mi>1024</span><span class=p>)</span>
<span class=n>result_sim</span> <span class=o>=</span> <span class=n>job_sim</span><span class=o>.</span><span class=n>result</span><span class=p>()</span>
<span class=n>counts</span> <span class=o>=</span> <span class=n>result_sim</span><span class=o>.</span><span class=n>get_counts</span><span class=p>(</span><span class=n>Q_Circuit</span><span class=p>)</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>qiskit.visualization</span> <span class=kn>import</span> <span class=n>plot_histogram</span>
<span class=n>plot_histogram</span><span class=p>(</span><span class=n>counts</span><span class=p>)</span>
</code></pre></div><p><img src=/n-blog/figures/2020-07-04-Grover_files/2020-07-04-Grover_19_0.svg alt=Circuit></p><h2 id=running-on-ibmq>Running on IBMQ</h2><p>We will choose the least busy backend with at least two qubits.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>qiskit</span> <span class=kn>import</span> <span class=n>IBMQ</span>
<span class=kn>from</span> <span class=nn>qiskit.providers.ibmq</span> <span class=kn>import</span> <span class=n>least_busy</span>

<span class=n>provider</span> <span class=o>=</span> <span class=n>IBMQ</span><span class=o>.</span><span class=n>load_account</span><span class=p>();</span>
<span class=n>num_qubits</span> <span class=o>=</span> <span class=mi>2</span>

<span class=n>backend</span> <span class=o>=</span> <span class=n>least_busy</span><span class=p>(</span><span class=n>provider</span><span class=o>.</span><span class=n>backends</span><span class=p>(</span><span class=n>filters</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=o>.</span><span class=n>configuration</span><span class=p>()</span><span class=o>.</span><span class=n>n_qubits</span> <span class=o>&gt;=</span> <span class=n>num_qubits</span> <span class=ow>and</span> <span class=ow>not</span> <span class=n>x</span><span class=o>.</span><span class=n>configuration</span><span class=p>()</span><span class=o>.</span><span class=n>simulator</span> <span class=ow>and</span> <span class=n>x</span><span class=o>.</span><span class=n>status</span><span class=p>()</span><span class=o>.</span><span class=n>operational</span><span class=o>==</span><span class=bp>True</span><span class=p>))</span>
<span class=n>backend</span>

</code></pre></div><pre><code>&lt;IBMQBackend('ibmq_ourense') from IBMQ(hub='ibm-q', group='open', project='main')&gt;
</code></pre><p>Submiting the job for the IBM Q platform</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>qiskit.tools.monitor</span> <span class=kn>import</span> <span class=n>job_monitor</span>

<span class=n>job_exp</span> <span class=o>=</span> <span class=n>Qsk</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=n>Q_Circuit</span><span class=p>,</span> <span class=n>backend</span><span class=o>=</span><span class=n>backend</span><span class=p>)</span>
<span class=n>job_monitor</span><span class=p>(</span><span class=n>job_exp</span><span class=p>)</span>
</code></pre></div><pre><code>Job Status: job has successfully run
</code></pre><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>result_exp</span> <span class=o>=</span> <span class=n>job_exp</span><span class=o>.</span><span class=n>result</span><span class=p>()</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>qiskit.visualization</span> <span class=kn>import</span> <span class=n>plot_histogram</span>
<span class=n>counts_exp</span> <span class=o>=</span> <span class=n>result_exp</span><span class=o>.</span><span class=n>get_counts</span><span class=p>(</span><span class=n>Q_Circuit</span><span class=p>)</span>
<span class=n>plot_histogram</span><span class=p>([</span><span class=n>counts_exp</span><span class=p>,</span><span class=n>counts</span><span class=p>],</span> <span class=n>legend</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;Device&#39;</span><span class=p>,</span> <span class=s1>&#39;Simulator&#39;</span><span class=p>])</span>
</code></pre></div><p><img src=/n-blog/figures/2020-07-04-Grover_files/2020-07-04-Grover_25_0.svg alt=Histogram></p><h1 id=references>References</h1><p>1 - Michael A. Nielsen and Isaac L. Chuang.Quantum Computation and Quantum Information: 10th Anniversary Edition.Cambridge University Press, 2010</p><p>2 - Giuliano Benenti, Giulio Casati, and Giuliano Strini.Principles of Quantum Computation and Information. World Scientific, 2004.</p><p>3 - <a href=https://qiskit.org/textbook/>Qiskit Book</a></p><hr><h3>Version Information</h3><table><tr><th>Qiskit Software</th><th>Version</th></tr><tr><td>Qiskit</td><td>0.19.1</td></tr><tr><td>Terra</td><td>0.14.1</td></tr><tr><td>Aer</td><td>0.5.1</td></tr><tr><td>Ignis</td><td>0.3.0</td></tr><tr><td>Aqua</td><td>0.7.0</td></tr><tr><td>IBM Q Provider</td><td>0.7.0</td></tr><tr><th>System information</th></tr><tr><td>Python</td><td>3.7.3 | packaged by conda-forge | (default, Jul 1 2019, 21:52:21)
[GCC 7.3.0]</td></tr><tr><td>OS</td><td>Linux</td></tr><tr><td>CPUs</td><td>2</td></tr><tr><td>Memory (Gb)</td><td>7.664028167724609</td></tr><tr><td colspan=2>Sat Jul 04 17:45:24 2020 -03</td></tr></table></div><footer class="post-footer clearfix"><div class=share><a class=icon-twitter href="https://twitter.com/share?text=Grover%20Algorithm&url=https%3a%2f%2fnahumsa.github.io%2fn-blog%2f2020-07-04-grover%2f" onclick="window.open(this.href,'twitter-share','width=550,height=235');return false;" aria-label="Share on Twitter"><i class="fa fa-twitter" aria-hidden=true></i></a></div></footer></article></div></div></div><footer class=footer><div class=container><div class=site-title-wrapper><h1 class=site-title><a href=https://nahumsa.github.io/n-blog/>n-blog</a></h1><a class="button-square button-jump-top js-jump-top" href=# aria-label="Back to Top"><i class="fa fa-angle-up" aria-hidden=true></i></a></div><p class=footer-copyright><span>&copy; 2021 / Powered by <a href=https://gohugo.io/>Hugo</a></span></p><p class=footer-copyright><span><a href=https://github.com/roryg/ghostwriter>Ghostwriter theme</a> By <a href=http://jollygoodthemes.com>JollyGoodThemes</a></span>
<span>/ <a href=https://github.com/jbub/ghostwriter>Ported</a> to Hugo By <a href=https://github.com/jbub>jbub</a></span></p></div></footer><script src=https://nahumsa.github.io/n-blog/js/jquery-1.11.3.min.js></script><script src=https://nahumsa.github.io/n-blog/js/jquery.fitvids.js></script><script src=https://nahumsa.github.io/n-blog/js/scripts.js></script></body></html>