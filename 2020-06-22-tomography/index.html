<!doctype html><html prefix="og: http://ogp.me/ns#"><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Quantum State Tomography</title><meta name=description content="1) Introduction Let&rsquo;s try to do the tomography of a given one-qubit quantum state just to understand the principle behind this procedure:
$$ \rho = \begin{pmatrix} \rho_{11} & \rho_{12} \\
\rho_{21} & \rho_{22} \end{pmatrix} = \frac{1}{2} \sum_{i=0}^3 S_i \sigma_i $$
Where $\rho_{11} + \rho_{22} = 1$, $\rho_{12} = \rho_{21}^*$, and $\sigma_i$ are the pauli matrices.
$$ \sigma_0 = I \ \ \ \sigma_1 = \sigma_x = \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix} \ \ \ \sigma_2 = \sigma_y = \begin{pmatrix} 0 & i \\ -i & 0 \end{pmatrix} \ \ \ \sigma_3 = \sigma_z = \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix} $$"><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=generator content="Hugo 0.82.0"><meta name=robots content="index,follow"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="Quantum State Tomography"><meta property="og:description" content="1) Introduction Let&rsquo;s try to do the tomography of a given one-qubit quantum state just to understand the principle behind this procedure:
$$ \rho = \begin{pmatrix} \rho_{11} & \rho_{12} \\
\rho_{21} & \rho_{22} \end{pmatrix} = \frac{1}{2} \sum_{i=0}^3 S_i \sigma_i $$
Where $\rho_{11} + \rho_{22} = 1$, $\rho_{12} = \rho_{21}^*$, and $\sigma_i$ are the pauli matrices.
$$ \sigma_0 = I \ \ \ \sigma_1 = \sigma_x = \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix} \ \ \ \sigma_2 = \sigma_y = \begin{pmatrix} 0 & i \\ -i & 0 \end{pmatrix} \ \ \ \sigma_3 = \sigma_z = \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix} $$"><meta property="og:type" content="article"><meta property="og:url" content="https://nahumsa.github.io/n-blog/2020-06-22-tomography/"><link rel=stylesheet href=https://nahumsa.github.io/n-blog/dist/site.css><link rel=stylesheet href=https://nahumsa.github.io/n-blog/dist/syntax.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,400,600,700,300&subset=latin,cyrillic-ext,latin-ext,cyrillic"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous><link rel="shortcut icon" type=image/jpg href=https://nahumsa.github.io/n-blog/favicon.ico><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}},window.addEventListener('load',a=>{document.querySelectorAll("mjx-container").forEach(function(a){a.parentElement.classList+='has-jax'})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-170504520-1','auto'),ga('send','pageview'))</script><div id=wrapper><header class=site-header><div class=container><div class=site-title-wrapper><h1 class=site-title><a href=https://nahumsa.github.io/n-blog/>n-blog</a></h1><a class="button-square button-social hint--top" data-hint=Twitter aria-label=Twitter href=https://twitter.com/sa_nahum rel=me><i class="fa fa-twitter" aria-hidden=true></i></a>
<a class="button-square button-social hint--top" data-hint=Github aria-label=Github href=https://github.com/nahumsa rel=me><i class="fa fa-github-alt" aria-hidden=true></i></a>
<a class="button-square button-social hint--top" data-hint=Email aria-label="Send an Email" href=mailto:nahumsa@cbpf.br><i class="fa fa-envelope" aria-hidden=true></i></a></div><ul class=site-nav></ul></div></header><div id=container><div class=container><article class=post-container itemscope itemtype=http://schema.org/BlogPosting><header class=post-header><h1 class=post-title itemprop="name headline">Quantum State Tomography</h1><p class="post-date post-line"><span>Published <time datetime=2020-06-22 itemprop=datePublished>Mon, Jun 22, 2020</time></span>
<span>by</span>
<span itemscope itemprop=author itemtype=https://schema.org/Person><span itemprop=name><a href=# itemprop=url rel=author></a></span></span></p></header><div class="post-content clearfix" itemprop=articleBody><h1 id=1-introduction>1) Introduction</h1><p>Let&rsquo;s try to do the tomography of a given one-qubit quantum state just to understand the principle behind this procedure:</p><p>$$
\rho = \begin{pmatrix}
\rho_{11} & \rho_{12} \\<br>\rho_{21} & \rho_{22}
\end{pmatrix} = \frac{1}{2} \sum_{i=0}^3 S_i \sigma_i
$$</p><p>Where $\rho_{11} + \rho_{22} = 1$, $\rho_{12} = \rho_{21}^*$, and $\sigma_i$ are the pauli matrices.</p><p>$$
\sigma_0 = I \ \ \ \sigma_1 = \sigma_x = \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix} \ \ \ \sigma_2 = \sigma_y = \begin{pmatrix} 0 & i \\ -i & 0 \end{pmatrix} \ \ \ \sigma_3 = \sigma_z = \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix}
$$</p><p>Our goal is to find $S_i$ an then characterize the state.</p><p>A problem is that the IBM quantum computers only measures on the Z axis, therefore we only can know $S_3$ that is associated as the expected value of the measurement along the Z axis.
We need to do a trick to be able to measure $\big&lt; X \big>$ and $\big&lt; Y \big>$.</p><p>Let&rsquo;s first check what are the eigenvectors of those operators.</p><ul><li><p>X has as eigenvectors $\left| + \right> = \frac{1}{\sqrt{2}} \bigg( \left| 0 \right> + \left| 1 \right> \bigg)$
and $\left| - \right> = \frac{1}{\sqrt{2}} \bigg( \left| 0 \right> - \left| 1 \right> \bigg)$ ;</p></li><li><p>Y has as eigenvectors $\left| i^+ \right> = \frac{1}{\sqrt{2}} \bigg( \left| 0 \right> + i\left| 1 \right> \bigg)$
and $\left| i^- \right> = \frac{1}{\sqrt{2}} \bigg( \left| 0 \right> - i\left| 1 \right> \bigg)$ ;</p></li></ul><p>Thus to measure on those bases we need only to add a way to generate those eigenvectors on the circuit:</p><ul><li>To generate X, we only need to apply the gate $H$.</li><li>To generate Y, we need to apply the gate $S^{\dagger}H$.</li></ul><h1 id=2-doing-quantum-state-tomography-by-hand-on-qiskit>2) Doing Quantum State Tomography by hand on qiskit</h1><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>import</span> <span style=color:#0cf;font-weight:700>qiskit</span> <span style=color:#069;font-weight:700>as</span> <span style=color:#0cf;font-weight:700>qsk</span>
<span style=color:#069;font-weight:700>import</span> <span style=color:#0cf;font-weight:700>numpy</span> <span style=color:#069;font-weight:700>as</span> <span style=color:#0cf;font-weight:700>np</span>
<span style=color:#069;font-weight:700>import</span> <span style=color:#0cf;font-weight:700>matplotlib.pyplot</span> <span style=color:#069;font-weight:700>as</span> <span style=color:#0cf;font-weight:700>plt</span>
</code></pre></div><p>In order to test this, consider we have the state $\left| \psi \right> = \frac{1}{\sqrt{2}} \big( \left| 0 \right> + \left| 1 \right> \big)$ and we want to do the tomography of this state.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>measure_X</span>(circuit,n):    
    circuit<span style=color:#555>.</span>barrier(n)
    circuit<span style=color:#555>.</span>h(n)
    circuit<span style=color:#555>.</span>measure(n,n)
    <span style=color:#069;font-weight:700>return</span> circuit

<span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>measure_Y</span>(circuit,n):    
    circuit<span style=color:#555>.</span>barrier(n)
    circuit<span style=color:#555>.</span>sdg(n)
    circuit<span style=color:#555>.</span>h(n)    
    circuit<span style=color:#555>.</span>measure(n,n)    
    <span style=color:#069;font-weight:700>return</span> circuit

<span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>tomography</span>(circuit):
    <span style=color:#c30>&#34;&#34;&#34; Tomography of a one qubit Circuit.
</span><span style=color:#c30>    &#34;&#34;&#34;</span>
    qc_list <span style=color:#555>=</span> []
    base <span style=color:#555>=</span> [<span style=color:#c30>&#39;X&#39;</span>, <span style=color:#c30>&#39;Y&#39;</span>, <span style=color:#c30>&#39;Z&#39;</span>]
    <span style=color:#069;font-weight:700>for</span> basis <span style=color:#000;font-weight:700>in</span> base:
        Q <span style=color:#555>=</span> qsk<span style=color:#555>.</span>QuantumCircuit(<span style=color:#f60>1</span>,<span style=color:#f60>1</span>)
        Q<span style=color:#555>.</span>append(circuit, [<span style=color:#f60>0</span>])
        <span style=color:#069;font-weight:700>if</span> basis <span style=color:#555>==</span> <span style=color:#c30>&#39;X&#39;</span>:
            measure_X(Q, <span style=color:#f60>0</span>)
            qc_list<span style=color:#555>.</span>append(Q)
        <span style=color:#069;font-weight:700>if</span> basis <span style=color:#555>==</span> <span style=color:#c30>&#39;Y&#39;</span>:
            measure_Y(Q,  <span style=color:#f60>0</span>)
            qc_list<span style=color:#555>.</span>append(Q)
        <span style=color:#069;font-weight:700>if</span> basis <span style=color:#555>==</span> <span style=color:#c30>&#39;Z&#39;</span>:
            Q<span style=color:#555>.</span>measure(<span style=color:#f60>0</span>,<span style=color:#f60>0</span>)
            qc_list<span style=color:#555>.</span>append(Q)
    <span style=color:#069;font-weight:700>return</span> qc_list, base
</code></pre></div><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>qc <span style=color:#555>=</span> qsk<span style=color:#555>.</span>QuantumCircuit(<span style=color:#f60>1</span>)
qc<span style=color:#555>.</span>h(<span style=color:#f60>0</span>)
qcs, bases <span style=color:#555>=</span> tomography(qc)
</code></pre></div><p>Running tomography</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>backend_sim <span style=color:#555>=</span> qsk<span style=color:#555>.</span>Aer<span style=color:#555>.</span>get_backend(<span style=color:#c30>&#39;qasm_simulator&#39;</span>)
job <span style=color:#555>=</span> qsk<span style=color:#555>.</span>execute(qcs, backend_sim, shots<span style=color:#555>=</span><span style=color:#f60>5000</span>)
result <span style=color:#555>=</span> job<span style=color:#555>.</span>result()

<span style=color:#069;font-weight:700>for</span> index, circuit <span style=color:#000;font-weight:700>in</span> <span style=color:#366>enumerate</span>(qcs):
    <span style=color:#069;font-weight:700>print</span>(result<span style=color:#555>.</span>get_counts(circuit))
    <span style=color:#069;font-weight:700>print</span>(f<span style=color:#c30>&#39;Base measured {bases[index]}</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#39;</span>)
</code></pre></div><pre><code>{'0': 5000}
Base measured X

{'0': 2484, '1': 2516}
Base measured Y

{'0': 2503, '1': 2497}
Base measured Z
</code></pre><p>Thus we have: X = 1, Y = 0 and Z = 0, because 0 is equivalent to +1 and 1 equivalent to -1. It is not exactly 0 because of statistical fluctiations.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>get_density_matrix</span>(measurements,circuits):
    <span style=color:#c30>&#34;&#34;&#34;Get density matrix from tomography measurements.
</span><span style=color:#c30>
</span><span style=color:#c30>    &#34;&#34;&#34;</span>
    density_matrix <span style=color:#555>=</span> np<span style=color:#555>.</span>eye(<span style=color:#f60>2</span>, dtype<span style=color:#555>=</span>np<span style=color:#555>.</span>complex128)
    sigma_x <span style=color:#555>=</span> np<span style=color:#555>.</span>array([[<span style=color:#f60>0</span>,<span style=color:#f60>1</span>],[<span style=color:#f60>1</span>,<span style=color:#f60>0</span>]])
    sigma_y <span style=color:#555>=</span> np<span style=color:#555>.</span>array([[<span style=color:#f60>0</span>,<span style=color:#555>-</span><span style=color:#f60>1j</span>],[<span style=color:#f60>1j</span>,<span style=color:#f60>0</span>]])
    sigma_z <span style=color:#555>=</span> np<span style=color:#555>.</span>array([[<span style=color:#f60>1</span>,<span style=color:#f60>0</span>],[<span style=color:#f60>0</span>,<span style=color:#555>-</span><span style=color:#f60>1</span>]])
    basis <span style=color:#555>=</span> [sigma_x, sigma_y, sigma_z]

    <span style=color:#069;font-weight:700>for</span> index <span style=color:#000;font-weight:700>in</span> <span style=color:#366>range</span>(<span style=color:#366>len</span>(circuits)):
        R <span style=color:#555>=</span> measurements<span style=color:#555>.</span>get_counts(index)
        
        <span style=color:#069;font-weight:700>if</span> <span style=color:#c30>&#39;0&#39;</span> <span style=color:#000;font-weight:700>in</span> R<span style=color:#555>.</span>keys() <span style=color:#000;font-weight:700>and</span> <span style=color:#c30>&#39;1&#39;</span> <span style=color:#000;font-weight:700>in</span> R<span style=color:#555>.</span>keys():
            zero <span style=color:#555>=</span> R[<span style=color:#c30>&#39;0&#39;</span>]
            one <span style=color:#555>=</span> R[<span style=color:#c30>&#39;1&#39;</span>]
        
        <span style=color:#069;font-weight:700>elif</span> <span style=color:#c30>&#39;1&#39;</span> <span style=color:#000;font-weight:700>in</span> R<span style=color:#555>.</span>keys():
            zero <span style=color:#555>=</span> <span style=color:#f60>0</span>
            one <span style=color:#555>=</span> R[<span style=color:#c30>&#39;1&#39;</span>]
        
        <span style=color:#069;font-weight:700>elif</span> <span style=color:#c30>&#39;0&#39;</span> <span style=color:#000;font-weight:700>in</span> R<span style=color:#555>.</span>keys():
            zero <span style=color:#555>=</span> R[<span style=color:#c30>&#39;0&#39;</span>]
            one <span style=color:#555>=</span> <span style=color:#f60>0</span>

        total <span style=color:#555>=</span> <span style=color:#366>sum</span>(<span style=color:#366>list</span>(R<span style=color:#555>.</span>values()))
        expected <span style=color:#555>=</span> (zero <span style=color:#555>-</span> one)<span style=color:#555>/</span>total        
        density_matrix <span style=color:#555>+=</span> expected <span style=color:#555>*</span> basis[index]

    <span style=color:#069;font-weight:700>return</span> <span style=color:#f60>0.5</span><span style=color:#555>*</span>density_matrix

density <span style=color:#555>=</span> get_density_matrix(result,qcs)
<span style=color:#069;font-weight:700>print</span>(density)
</code></pre></div><pre><code>[[0.5006+0.j     0.5   +0.0032j]
 [0.5   -0.0032j 0.4994+0.j    ]]
</code></pre><p>Writing the density matrix:
$$
\rho = \frac{1}{2} \begin{pmatrix}
1 & 1 \\<br>1 & 1
\end{pmatrix}
$$</p><h1 id=3-doing-quantum-state-tomography-using-ignis>3) Doing Quantum State Tomography using Ignis</h1><p>Qiskit has a module inside ignis to do <a href=https://qiskit-staging.mybluemix.net/documentation/ignis/tomography.html>tomography</a> that does exactly what we&rsquo;ve done before, but is generalized for multiple qubits as input.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>from</span> <span style=color:#0cf;font-weight:700>qiskit.ignis.verification.tomography</span> <span style=color:#069;font-weight:700>import</span> state_tomography_circuits

tomography_circuits <span style=color:#555>=</span> state_tomography_circuits(qc, [<span style=color:#f60>0</span>], meas_labels<span style=color:#555>=</span><span style=color:#c30>&#39;Pauli&#39;</span>, meas_basis<span style=color:#555>=</span><span style=color:#c30>&#39;Pauli&#39;</span>)
</code></pre></div><p>As a check, let&rsquo;s see how they measure the Y basis, and we can verify that it is the same way as we did before.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>tomography_circuits[<span style=color:#f60>1</span>]<span style=color:#555>.</span>draw(<span style=color:#c30>&#39;mpl&#39;</span>)
</code></pre></div><p><img src=/n-blog/figures/2020-06-22-Tomography_files/2020-06-22-Tomography_14_0.svg alt="tomography circuit"></p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>backend_sim <span style=color:#555>=</span> qsk<span style=color:#555>.</span>Aer<span style=color:#555>.</span>get_backend(<span style=color:#c30>&#39;qasm_simulator&#39;</span>)
job <span style=color:#555>=</span> qsk<span style=color:#555>.</span>execute(tomography_circuits, backend_sim, shots<span style=color:#555>=</span><span style=color:#f60>5000</span>)
result <span style=color:#555>=</span> job<span style=color:#555>.</span>result()
</code></pre></div><p>They also has a function to transform the results to a density matrix which treats the state tomography as an optimization problem. The <code>fit</code> method has several methods for fitting the tomography results, such as <code>cvx</code> which is convex optimization and <code>lstsq</code> which makes uses the least square optimization.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>from</span> <span style=color:#0cf;font-weight:700>qiskit.ignis.verification.tomography</span> <span style=color:#069;font-weight:700>import</span> StateTomographyFitter

state_fitter <span style=color:#555>=</span> StateTomographyFitter(result, tomography_circuits, meas_basis<span style=color:#555>=</span><span style=color:#c30>&#39;Pauli&#39;</span>)
</code></pre></div><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>density_matrix <span style=color:#555>=</span> state_fitter<span style=color:#555>.</span>fit(method<span style=color:#555>=</span><span style=color:#c30>&#39;lstsq&#39;</span>)
<span style=color:#069;font-weight:700>print</span>(density_matrix)
</code></pre></div><pre><code>[[0.49040221+0.j         0.49988484+0.00479889j]
 [0.49988484-0.00479889j 0.50959779+0.j        ]]
</code></pre><p>Which is approximately what we expect, as shown before.</p><h1 id=4-state-tomography-of-3-qubits>4) State tomography of 3 qubits</h1><p>For this example, let&rsquo;s use the GHZ state:</p><p>$$
\left| \psi \right> = \frac{1}{\sqrt{2}} \bigg( \left| 000 \right> + \left| 111 \right> \bigg)
$$</p><p>This state is simply constructed using an H gate and two CNOT gates:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>qc <span style=color:#555>=</span> qsk<span style=color:#555>.</span>QuantumCircuit(<span style=color:#f60>3</span>)
qc<span style=color:#555>.</span>h(<span style=color:#f60>0</span>)
qc<span style=color:#555>.</span>cx(<span style=color:#f60>0</span>,<span style=color:#f60>1</span>)
qc<span style=color:#555>.</span>cx(<span style=color:#f60>0</span>,<span style=color:#f60>2</span>)
qc<span style=color:#555>.</span>draw(<span style=color:#c30>&#39;mpl&#39;</span>)
</code></pre></div><p><img src=/n-blog/figures/2020-06-22-Tomography_files/2020-06-22-Tomography_22_0.svg alt="tomography circuit"></p><p>In order to indicate which qubits we want to do tomography, we need to put an list after choosing the circuit that we want to do tomography. In this case, we want to do tomography of all qubits of qc, therefore we need to put <code>[0,1,2]</code>.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>from</span> <span style=color:#0cf;font-weight:700>qiskit.ignis.verification.tomography</span> <span style=color:#069;font-weight:700>import</span> state_tomography_circuits

tomography_circuits <span style=color:#555>=</span> state_tomography_circuits(qc, [<span style=color:#f60>0</span>,<span style=color:#f60>1</span>,<span style=color:#f60>2</span>], 
                                                meas_labels<span style=color:#555>=</span><span style=color:#c30>&#39;Pauli&#39;</span>, 
                                                meas_basis<span style=color:#555>=</span><span style=color:#c30>&#39;Pauli&#39;</span>)
backend_sim <span style=color:#555>=</span> qsk<span style=color:#555>.</span>Aer<span style=color:#555>.</span>get_backend(<span style=color:#c30>&#39;qasm_simulator&#39;</span>)
job <span style=color:#555>=</span> qsk<span style=color:#555>.</span>execute(tomography_circuits, backend_sim, shots<span style=color:#555>=</span><span style=color:#f60>5000</span>)
result <span style=color:#555>=</span> job<span style=color:#555>.</span>result()
</code></pre></div><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>from</span> <span style=color:#0cf;font-weight:700>qiskit.ignis.verification.tomography</span> <span style=color:#069;font-weight:700>import</span> StateTomographyFitter

state_fitter <span style=color:#555>=</span> StateTomographyFitter(result, tomography_circuits, meas_basis<span style=color:#555>=</span><span style=color:#c30>&#39;Pauli&#39;</span>)
</code></pre></div><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>density_matrix <span style=color:#555>=</span> state_fitter<span style=color:#555>.</span>fit(method<span style=color:#555>=</span><span style=color:#c30>&#39;lstsq&#39;</span>)
</code></pre></div><p>Let&rsquo;s define a helper function that plots the real and imaginary part as a grey scale image:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>plot_density_matrix</span>(DM):
    <span style=color:#c30>&#34;&#34;&#34;Helper function to plot density matrices.
</span><span style=color:#c30>
</span><span style=color:#c30>    Parameters
</span><span style=color:#c30>    ----------------------------------------------
</span><span style=color:#c30>    DM(np.array): Density Matrix.
</span><span style=color:#c30>    
</span><span style=color:#c30>    &#34;&#34;&#34;</span>
    <span style=color:#069;font-weight:700>from</span> <span style=color:#0cf;font-weight:700>matplotlib.ticker</span> <span style=color:#069;font-weight:700>import</span> MaxNLocator
    
    fig <span style=color:#555>=</span> plt<span style=color:#555>.</span>figure(figsize<span style=color:#555>=</span>(<span style=color:#f60>16</span>,<span style=color:#f60>10</span>))
    gs <span style=color:#555>=</span> fig<span style=color:#555>.</span>add_gridspec(<span style=color:#f60>1</span>, <span style=color:#f60>2</span>)
    ax1 <span style=color:#555>=</span> fig<span style=color:#555>.</span>add_subplot(gs[<span style=color:#f60>0</span>, <span style=color:#f60>0</span>])
    ax2 <span style=color:#555>=</span> fig<span style=color:#555>.</span>add_subplot(gs[<span style=color:#f60>0</span>, <span style=color:#f60>1</span>])

    im <span style=color:#555>=</span> ax1<span style=color:#555>.</span>imshow(np<span style=color:#555>.</span>real(DM), cmap<span style=color:#555>=</span><span style=color:#c30>&#39;Greys&#39;</span>)
    ax1<span style=color:#555>.</span>yaxis<span style=color:#555>.</span>set_major_locator(MaxNLocator(integer<span style=color:#555>=</span>True))
    ax1<span style=color:#555>.</span>xaxis<span style=color:#555>.</span>set_major_locator(MaxNLocator(integer<span style=color:#555>=</span>True))
    ax1<span style=color:#555>.</span>set_title(<span style=color:#c30>&#39;Real Part&#39;</span>,size<span style=color:#555>=</span><span style=color:#f60>16</span>)
    plt<span style=color:#555>.</span>colorbar(im, ax<span style=color:#555>=</span>ax1)

    im <span style=color:#555>=</span> ax2<span style=color:#555>.</span>imshow(np<span style=color:#555>.</span>imag(DM), cmap<span style=color:#555>=</span><span style=color:#c30>&#39;Greys&#39;</span>)
    plt<span style=color:#555>.</span>colorbar(im, ax<span style=color:#555>=</span>ax2)
    ax2<span style=color:#555>.</span>yaxis<span style=color:#555>.</span>set_major_locator(MaxNLocator(integer<span style=color:#555>=</span>True))
    ax2<span style=color:#555>.</span>xaxis<span style=color:#555>.</span>set_major_locator(MaxNLocator(integer<span style=color:#555>=</span>True))
    ax2<span style=color:#555>.</span>set_title(<span style=color:#c30>&#39;Imaginary Part&#39;</span>,size<span style=color:#555>=</span><span style=color:#f60>16</span>)
    plt<span style=color:#555>.</span>show()
</code></pre></div><p>Ploting the density matrix, we see that there are states only on the first and last column (row), each column (row) represents a quantum state on the computational basis, for this case the states represented are $\left| 000 \right>$ and $\left| 111 \right>$ respectively. We can ignore the imaginary part, since is is only random noise.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>plot_density_matrix(density_matrix)
</code></pre></div><p><img src=/n-blog/figures/2020-06-22-Tomography_files/2020-06-22-Tomography_26_0.svg alt="Density matrix"></p><p>The code for this post is on <a href=https://github.com/nahumsa/Introduction-to-IBM_Qiskit/blob/master/Notebooks/Tomography.ipynb>github</a>.</p><h1 id=references>References</h1><p>1 - <a href=http://research.physics.illinois.edu/QI/Photonics/tomography-files/tomo_chapter_2004.pdf>Altepeter et al - Quantum State Tomography</a></p><p>2 - <a href=https://qiskit.org/documentation/apidoc/verification.html#tomography>Qiskit Ignis Documentation</a></p><hr><h3>Version Information</h3><table><tr><th>Qiskit Software</th><th>Version</th></tr><tr><td>Qiskit</td><td>0.19.1</td></tr><tr><td>Terra</td><td>0.14.1</td></tr><tr><td>Aer</td><td>0.5.1</td></tr><tr><td>Ignis</td><td>0.3.0</td></tr><tr><td>Aqua</td><td>0.7.0</td></tr><tr><td>IBM Q Provider</td><td>0.7.0</td></tr><tr><th>System information</th></tr><tr><td>Python</td><td>3.7.3 | packaged by conda-forge | (default, Jul 1 2019, 21:52:21)
[GCC 7.3.0]</td></tr><tr><td>OS</td><td>Linux</td></tr><tr><td>CPUs</td><td>2</td></tr><tr><td>Memory (Gb)</td><td>7.664028167724609</td></tr><tr><td colspan=2>Sat May 23 17:14:48 2020 -03</td></tr></table></div><footer class="post-footer clearfix"><div class=share><a class=icon-twitter href="https://twitter.com/share?text=Quantum%20State%20Tomography&url=https%3a%2f%2fnahumsa.github.io%2fn-blog%2f2020-06-22-tomography%2f" onclick="return window.open(this.href,'twitter-share','width=550,height=235'),!1" aria-label="Share on Twitter"><i class="fa fa-twitter" aria-hidden=true></i></a></div></footer></article></div></div></div><footer class=footer><div class=container><div class=site-title-wrapper><h1 class=site-title><a href=https://nahumsa.github.io/n-blog/>n-blog</a></h1><a class="button-square button-jump-top js-jump-top" href=# aria-label="Back to Top"><i class="fa fa-angle-up" aria-hidden=true></i></a></div><p class=footer-copyright><span>&copy; 2021 / Powered by <a href=https://gohugo.io/>Hugo</a></span></p><p class=footer-copyright><span><a href=https://github.com/roryg/ghostwriter>Ghostwriter theme</a> By <a href=http://jollygoodthemes.com>JollyGoodThemes</a></span>
<span>/ <a href=https://github.com/jbub/ghostwriter>Ported</a> to Hugo By <a href=https://github.com/jbub>jbub</a></span></p></div></footer><script src=https://nahumsa.github.io/n-blog/js/jquery-1.11.3.min.js></script><script src=https://nahumsa.github.io/n-blog/js/jquery.fitvids.js></script><script src=https://nahumsa.github.io/n-blog/js/scripts.js></script></body></html>