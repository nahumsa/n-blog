<!doctype html><html prefix="og: http://ogp.me/ns#"><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Quantum State Tomography</title><meta name=description content="1) Introduction Let&rsquo;s try to do the tomography of a given one-qubit quantum state just to understand the principle behind this procedure:
$$ \rho = \begin{pmatrix} \rho_{11} & \rho_{12} \\
\rho_{21} & \rho_{22} \end{pmatrix} = \frac{1}{2} \sum_{i=0}^3 S_i \sigma_i $$
Where $\rho_{11} + \rho_{22} = 1$, $\rho_{12} = \rho_{21}^*$, and $\sigma_i$ are the pauli matrices.
$$ \sigma_0 = I \ \ \ \sigma_1 = \sigma_x = \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix} \ \ \ \sigma_2 = \sigma_y = \begin{pmatrix} 0 & i \\ -i & 0 \end{pmatrix} \ \ \ \sigma_3 = \sigma_z = \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix} $$"><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=generator content="Hugo 0.80.0"><meta name=robots content="index,follow"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="Quantum State Tomography"><meta property="og:description" content="1) Introduction Let&rsquo;s try to do the tomography of a given one-qubit quantum state just to understand the principle behind this procedure:
$$ \rho = \begin{pmatrix} \rho_{11} & \rho_{12} \\
\rho_{21} & \rho_{22} \end{pmatrix} = \frac{1}{2} \sum_{i=0}^3 S_i \sigma_i $$
Where $\rho_{11} + \rho_{22} = 1$, $\rho_{12} = \rho_{21}^*$, and $\sigma_i$ are the pauli matrices.
$$ \sigma_0 = I \ \ \ \sigma_1 = \sigma_x = \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix} \ \ \ \sigma_2 = \sigma_y = \begin{pmatrix} 0 & i \\ -i & 0 \end{pmatrix} \ \ \ \sigma_3 = \sigma_z = \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix} $$"><meta property="og:type" content="article"><meta property="og:url" content="https://nahumsa.github.io/n-blog/2020-06-22-tomography/"><link rel=stylesheet href=https://nahumsa.github.io/n-blog/dist/site.css><link rel=stylesheet href=https://nahumsa.github.io/n-blog/dist/syntax.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,400,600,700,300&subset=latin,cyrillic-ext,latin-ext,cyrillic"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous><link rel="shortcut icon" type=image/jpg href=https://nahumsa.github.io/n-blog/favicon.ico><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:true,processEnvironments:true},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}};window.addEventListener('load',(event)=>{document.querySelectorAll("mjx-container").forEach(function(x){x.parentElement.classList+='has-jax'})});</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-170504520-1','auto');ga('send','pageview');}</script><div id=wrapper><header class=site-header><div class=container><div class=site-title-wrapper><h1 class=site-title><a href=https://nahumsa.github.io/n-blog/>n-blog</a></h1><a class="button-square button-social hint--top" data-hint=Twitter aria-label=Twitter href=https://twitter.com/sa_nahum rel=me><i class="fa fa-twitter" aria-hidden=true></i></a><a class="button-square button-social hint--top" data-hint=Github aria-label=Github href=https://github.com/nahumsa rel=me><i class="fa fa-github-alt" aria-hidden=true></i></a><a class="button-square button-social hint--top" data-hint=Email aria-label="Send an Email" href=mailto:nahumsa@cbpf.br><i class="fa fa-envelope" aria-hidden=true></i></a></div><ul class=site-nav></ul></div></header><div id=container><div class=container><article class=post-container itemscope itemtype=http://schema.org/BlogPosting><header class=post-header><h1 class=post-title itemprop="name headline">Quantum State Tomography</h1><p class="post-date post-line"><span>Published <time datetime=2020-06-22 itemprop=datePublished>Mon, Jun 22, 2020</time></span>
<span>by</span>
<span itemscope itemprop=author itemtype=https://schema.org/Person><span itemprop=name><a href=# itemprop=url rel=author></a></span></span></p></header><div class="post-content clearfix" itemprop=articleBody><h1 id=1-introduction>1) Introduction</h1><p>Let&rsquo;s try to do the tomography of a given one-qubit quantum state just to understand the principle behind this procedure:</p><p>$$
\rho = \begin{pmatrix}
\rho_{11} & \rho_{12} \\<br>\rho_{21} & \rho_{22}
\end{pmatrix} = \frac{1}{2} \sum_{i=0}^3 S_i \sigma_i
$$</p><p>Where $\rho_{11} + \rho_{22} = 1$, $\rho_{12} = \rho_{21}^*$, and $\sigma_i$ are the pauli matrices.</p><p>$$
\sigma_0 = I \ \ \ \sigma_1 = \sigma_x = \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix} \ \ \ \sigma_2 = \sigma_y = \begin{pmatrix} 0 & i \\ -i & 0 \end{pmatrix} \ \ \ \sigma_3 = \sigma_z = \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix}
$$</p><p>Our goal is to find $S_i$ an then characterize the state.</p><p>A problem is that the IBM quantum computers only measures on the Z axis, therefore we only can know $S_3$ that is associated as the expected value of the measurement along the Z axis.
We need to do a trick to be able to measure $\big&lt; X \big>$ and $\big&lt; Y \big>$.</p><p>Let&rsquo;s first check what are the eigenvectors of those operators.</p><ul><li><p>X has as eigenvectors $\left| + \right> = \frac{1}{\sqrt{2}} \bigg( \left| 0 \right> + \left| 1 \right> \bigg)$
and $\left| - \right> = \frac{1}{\sqrt{2}} \bigg( \left| 0 \right> - \left| 1 \right> \bigg)$ ;</p></li><li><p>Y has as eigenvectors $\left| i^+ \right> = \frac{1}{\sqrt{2}} \bigg( \left| 0 \right> + i\left| 1 \right> \bigg)$
and $\left| i^- \right> = \frac{1}{\sqrt{2}} \bigg( \left| 0 \right> - i\left| 1 \right> \bigg)$ ;</p></li></ul><p>Thus to measure on those bases we need only to add a way to generate those eigenvectors on the circuit:</p><ul><li>To generate X, we only need to apply the gate $H$.</li><li>To generate Y, we need to apply the gate $S^{\dagger}H$.</li></ul><h1 id=2-doing-quantum-state-tomography-by-hand-on-qiskit>2) Doing Quantum State Tomography by hand on qiskit</h1><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>qiskit</span> <span class=kn>as</span> <span class=nn>qsk</span>
<span class=kn>import</span> <span class=nn>numpy</span> <span class=kn>as</span> <span class=nn>np</span>
<span class=kn>import</span> <span class=nn>matplotlib.pyplot</span> <span class=kn>as</span> <span class=nn>plt</span>
</code></pre></div><p>In order to test this, consider we have the state $\left| \psi \right> = \frac{1}{\sqrt{2}} \big( \left| 0 \right> + \left| 1 \right> \big)$ and we want to do the tomography of this state.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>measure_X</span><span class=p>(</span><span class=n>circuit</span><span class=p>,</span><span class=n>n</span><span class=p>):</span>    
    <span class=n>circuit</span><span class=o>.</span><span class=n>barrier</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>
    <span class=n>circuit</span><span class=o>.</span><span class=n>h</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>
    <span class=n>circuit</span><span class=o>.</span><span class=n>measure</span><span class=p>(</span><span class=n>n</span><span class=p>,</span><span class=n>n</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>circuit</span>

<span class=k>def</span> <span class=nf>measure_Y</span><span class=p>(</span><span class=n>circuit</span><span class=p>,</span><span class=n>n</span><span class=p>):</span>    
    <span class=n>circuit</span><span class=o>.</span><span class=n>barrier</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>
    <span class=n>circuit</span><span class=o>.</span><span class=n>sdg</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>
    <span class=n>circuit</span><span class=o>.</span><span class=n>h</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>    
    <span class=n>circuit</span><span class=o>.</span><span class=n>measure</span><span class=p>(</span><span class=n>n</span><span class=p>,</span><span class=n>n</span><span class=p>)</span>    
    <span class=k>return</span> <span class=n>circuit</span>

<span class=k>def</span> <span class=nf>tomography</span><span class=p>(</span><span class=n>circuit</span><span class=p>):</span>
    <span class=s2>&#34;&#34;&#34; Tomography of a one qubit Circuit.
</span><span class=s2>    &#34;&#34;&#34;</span>
    <span class=n>qc_list</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=n>base</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;X&#39;</span><span class=p>,</span> <span class=s1>&#39;Y&#39;</span><span class=p>,</span> <span class=s1>&#39;Z&#39;</span><span class=p>]</span>
    <span class=k>for</span> <span class=n>basis</span> <span class=ow>in</span> <span class=n>base</span><span class=p>:</span>
        <span class=n>Q</span> <span class=o>=</span> <span class=n>qsk</span><span class=o>.</span><span class=n>QuantumCircuit</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>)</span>
        <span class=n>Q</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>circuit</span><span class=p>,</span> <span class=p>[</span><span class=mi>0</span><span class=p>])</span>
        <span class=k>if</span> <span class=n>basis</span> <span class=o>==</span> <span class=s1>&#39;X&#39;</span><span class=p>:</span>
            <span class=n>measure_X</span><span class=p>(</span><span class=n>Q</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
            <span class=n>qc_list</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>Q</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>basis</span> <span class=o>==</span> <span class=s1>&#39;Y&#39;</span><span class=p>:</span>
            <span class=n>measure_Y</span><span class=p>(</span><span class=n>Q</span><span class=p>,</span>  <span class=mi>0</span><span class=p>)</span>
            <span class=n>qc_list</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>Q</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>basis</span> <span class=o>==</span> <span class=s1>&#39;Z&#39;</span><span class=p>:</span>
            <span class=n>Q</span><span class=o>.</span><span class=n>measure</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>)</span>
            <span class=n>qc_list</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>Q</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>qc_list</span><span class=p>,</span> <span class=n>base</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>qc</span> <span class=o>=</span> <span class=n>qsk</span><span class=o>.</span><span class=n>QuantumCircuit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
<span class=n>qc</span><span class=o>.</span><span class=n>h</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
<span class=n>qcs</span><span class=p>,</span> <span class=n>bases</span> <span class=o>=</span> <span class=n>tomography</span><span class=p>(</span><span class=n>qc</span><span class=p>)</span>
</code></pre></div><p>Running tomography</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>backend_sim</span> <span class=o>=</span> <span class=n>qsk</span><span class=o>.</span><span class=n>Aer</span><span class=o>.</span><span class=n>get_backend</span><span class=p>(</span><span class=s1>&#39;qasm_simulator&#39;</span><span class=p>)</span>
<span class=n>job</span> <span class=o>=</span> <span class=n>qsk</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=n>qcs</span><span class=p>,</span> <span class=n>backend_sim</span><span class=p>,</span> <span class=n>shots</span><span class=o>=</span><span class=mi>5000</span><span class=p>)</span>
<span class=n>result</span> <span class=o>=</span> <span class=n>job</span><span class=o>.</span><span class=n>result</span><span class=p>()</span>

<span class=k>for</span> <span class=n>index</span><span class=p>,</span> <span class=n>circuit</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>qcs</span><span class=p>):</span>
    <span class=k>print</span><span class=p>(</span><span class=n>result</span><span class=o>.</span><span class=n>get_counts</span><span class=p>(</span><span class=n>circuit</span><span class=p>))</span>
    <span class=k>print</span><span class=p>(</span><span class=n>f</span><span class=s1>&#39;Base measured {bases[index]}</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>)</span>
</code></pre></div><pre><code>{'0': 5000}
Base measured X

{'0': 2484, '1': 2516}
Base measured Y

{'0': 2503, '1': 2497}
Base measured Z
</code></pre><p>Thus we have: X = 1, Y = 0 and Z = 0, because 0 is equivalent to +1 and 1 equivalent to -1. It is not exactly 0 because of statistical fluctiations.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>get_density_matrix</span><span class=p>(</span><span class=n>measurements</span><span class=p>,</span><span class=n>circuits</span><span class=p>):</span>
    <span class=s2>&#34;&#34;&#34;Get density matrix from tomography measurements.
</span><span class=s2>
</span><span class=s2>    &#34;&#34;&#34;</span>
    <span class=n>density_matrix</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>eye</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>complex128</span><span class=p>)</span>
    <span class=n>sigma_x</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mi>0</span><span class=p>,</span><span class=mi>1</span><span class=p>],[</span><span class=mi>1</span><span class=p>,</span><span class=mi>0</span><span class=p>]])</span>
    <span class=n>sigma_y</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mi>0</span><span class=p>,</span><span class=o>-</span><span class=mi>1j</span><span class=p>],[</span><span class=mi>1j</span><span class=p>,</span><span class=mi>0</span><span class=p>]])</span>
    <span class=n>sigma_z</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mi>1</span><span class=p>,</span><span class=mi>0</span><span class=p>],[</span><span class=mi>0</span><span class=p>,</span><span class=o>-</span><span class=mi>1</span><span class=p>]])</span>
    <span class=n>basis</span> <span class=o>=</span> <span class=p>[</span><span class=n>sigma_x</span><span class=p>,</span> <span class=n>sigma_y</span><span class=p>,</span> <span class=n>sigma_z</span><span class=p>]</span>

    <span class=k>for</span> <span class=n>index</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>circuits</span><span class=p>)):</span>
        <span class=n>R</span> <span class=o>=</span> <span class=n>measurements</span><span class=o>.</span><span class=n>get_counts</span><span class=p>(</span><span class=n>index</span><span class=p>)</span>
        
        <span class=k>if</span> <span class=s1>&#39;0&#39;</span> <span class=ow>in</span> <span class=n>R</span><span class=o>.</span><span class=n>keys</span><span class=p>()</span> <span class=ow>and</span> <span class=s1>&#39;1&#39;</span> <span class=ow>in</span> <span class=n>R</span><span class=o>.</span><span class=n>keys</span><span class=p>():</span>
            <span class=n>zero</span> <span class=o>=</span> <span class=n>R</span><span class=p>[</span><span class=s1>&#39;0&#39;</span><span class=p>]</span>
            <span class=n>one</span> <span class=o>=</span> <span class=n>R</span><span class=p>[</span><span class=s1>&#39;1&#39;</span><span class=p>]</span>
        
        <span class=k>elif</span> <span class=s1>&#39;1&#39;</span> <span class=ow>in</span> <span class=n>R</span><span class=o>.</span><span class=n>keys</span><span class=p>():</span>
            <span class=n>zero</span> <span class=o>=</span> <span class=mi>0</span>
            <span class=n>one</span> <span class=o>=</span> <span class=n>R</span><span class=p>[</span><span class=s1>&#39;1&#39;</span><span class=p>]</span>
        
        <span class=k>elif</span> <span class=s1>&#39;0&#39;</span> <span class=ow>in</span> <span class=n>R</span><span class=o>.</span><span class=n>keys</span><span class=p>():</span>
            <span class=n>zero</span> <span class=o>=</span> <span class=n>R</span><span class=p>[</span><span class=s1>&#39;0&#39;</span><span class=p>]</span>
            <span class=n>one</span> <span class=o>=</span> <span class=mi>0</span>

        <span class=n>total</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>(</span><span class=nb>list</span><span class=p>(</span><span class=n>R</span><span class=o>.</span><span class=n>values</span><span class=p>()))</span>
        <span class=n>expected</span> <span class=o>=</span> <span class=p>(</span><span class=n>zero</span> <span class=o>-</span> <span class=n>one</span><span class=p>)</span><span class=o>/</span><span class=n>total</span>        
        <span class=n>density_matrix</span> <span class=o>+=</span> <span class=n>expected</span> <span class=o>*</span> <span class=n>basis</span><span class=p>[</span><span class=n>index</span><span class=p>]</span>

    <span class=k>return</span> <span class=mf>0.5</span><span class=o>*</span><span class=n>density_matrix</span>

<span class=n>density</span> <span class=o>=</span> <span class=n>get_density_matrix</span><span class=p>(</span><span class=n>result</span><span class=p>,</span><span class=n>qcs</span><span class=p>)</span>
<span class=k>print</span><span class=p>(</span><span class=n>density</span><span class=p>)</span>
</code></pre></div><pre><code>[[0.5006+0.j     0.5   +0.0032j]
 [0.5   -0.0032j 0.4994+0.j    ]]
</code></pre><p>Writing the density matrix:
$$
\rho = \frac{1}{2} \begin{pmatrix}
1 & 1 \\<br>1 & 1
\end{pmatrix}
$$</p><h1 id=3-doing-quantum-state-tomography-using-ignis>3) Doing Quantum State Tomography using Ignis</h1><p>Qiskit has a module inside ignis to do <a href=https://qiskit-staging.mybluemix.net/documentation/ignis/tomography.html>tomography</a> that does exactly what we&rsquo;ve done before, but is generalized for multiple qubits as input.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>qiskit.ignis.verification.tomography</span> <span class=kn>import</span> <span class=n>state_tomography_circuits</span>

<span class=n>tomography_circuits</span> <span class=o>=</span> <span class=n>state_tomography_circuits</span><span class=p>(</span><span class=n>qc</span><span class=p>,</span> <span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>meas_labels</span><span class=o>=</span><span class=s1>&#39;Pauli&#39;</span><span class=p>,</span> <span class=n>meas_basis</span><span class=o>=</span><span class=s1>&#39;Pauli&#39;</span><span class=p>)</span>
</code></pre></div><p>As a check, let&rsquo;s see how they measure the Y basis, and we can verify that it is the same way as we did before.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>tomography_circuits</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>draw</span><span class=p>(</span><span class=s1>&#39;mpl&#39;</span><span class=p>)</span>
</code></pre></div><p><img src=/n-blog/figures/2020-06-22-Tomography_files/2020-06-22-Tomography_14_0.svg alt="tomography circuit"></p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>backend_sim</span> <span class=o>=</span> <span class=n>qsk</span><span class=o>.</span><span class=n>Aer</span><span class=o>.</span><span class=n>get_backend</span><span class=p>(</span><span class=s1>&#39;qasm_simulator&#39;</span><span class=p>)</span>
<span class=n>job</span> <span class=o>=</span> <span class=n>qsk</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=n>tomography_circuits</span><span class=p>,</span> <span class=n>backend_sim</span><span class=p>,</span> <span class=n>shots</span><span class=o>=</span><span class=mi>5000</span><span class=p>)</span>
<span class=n>result</span> <span class=o>=</span> <span class=n>job</span><span class=o>.</span><span class=n>result</span><span class=p>()</span>
</code></pre></div><p>They also has a function to transform the results to a density matrix which treats the state tomography as an optimization problem. The <code>fit</code> method has several methods for fitting the tomography results, such as <code>cvx</code> which is convex optimization and <code>lstsq</code> which makes uses the least square optimization.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>qiskit.ignis.verification.tomography</span> <span class=kn>import</span> <span class=n>StateTomographyFitter</span>

<span class=n>state_fitter</span> <span class=o>=</span> <span class=n>StateTomographyFitter</span><span class=p>(</span><span class=n>result</span><span class=p>,</span> <span class=n>tomography_circuits</span><span class=p>,</span> <span class=n>meas_basis</span><span class=o>=</span><span class=s1>&#39;Pauli&#39;</span><span class=p>)</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>density_matrix</span> <span class=o>=</span> <span class=n>state_fitter</span><span class=o>.</span><span class=n>fit</span><span class=p>(</span><span class=n>method</span><span class=o>=</span><span class=s1>&#39;lstsq&#39;</span><span class=p>)</span>
<span class=k>print</span><span class=p>(</span><span class=n>density_matrix</span><span class=p>)</span>
</code></pre></div><pre><code>[[0.49040221+0.j         0.49988484+0.00479889j]
 [0.49988484-0.00479889j 0.50959779+0.j        ]]
</code></pre><p>Which is approximately what we expect, as shown before.</p><h1 id=4-state-tomography-of-3-qubits>4) State tomography of 3 qubits</h1><p>For this example, let&rsquo;s use the GHZ state:</p><p>$$
\left| \psi \right> = \frac{1}{\sqrt{2}} \bigg( \left| 000 \right> + \left| 111 \right> \bigg)
$$</p><p>This state is simply constructed using an H gate and two CNOT gates:</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>qc</span> <span class=o>=</span> <span class=n>qsk</span><span class=o>.</span><span class=n>QuantumCircuit</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
<span class=n>qc</span><span class=o>.</span><span class=n>h</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
<span class=n>qc</span><span class=o>.</span><span class=n>cx</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>1</span><span class=p>)</span>
<span class=n>qc</span><span class=o>.</span><span class=n>cx</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>2</span><span class=p>)</span>
<span class=n>qc</span><span class=o>.</span><span class=n>draw</span><span class=p>(</span><span class=s1>&#39;mpl&#39;</span><span class=p>)</span>
</code></pre></div><p><img src=/n-blog/figures/2020-06-22-Tomography_files/2020-06-22-Tomography_22_0.svg alt="tomography circuit"></p><p>In order to indicate which qubits we want to do tomography, we need to put an list after choosing the circuit that we want to do tomography. In this case, we want to do tomography of all qubits of qc, therefore we need to put <code>[0,1,2]</code>.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>qiskit.ignis.verification.tomography</span> <span class=kn>import</span> <span class=n>state_tomography_circuits</span>

<span class=n>tomography_circuits</span> <span class=o>=</span> <span class=n>state_tomography_circuits</span><span class=p>(</span><span class=n>qc</span><span class=p>,</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>],</span> 
                                                <span class=n>meas_labels</span><span class=o>=</span><span class=s1>&#39;Pauli&#39;</span><span class=p>,</span> 
                                                <span class=n>meas_basis</span><span class=o>=</span><span class=s1>&#39;Pauli&#39;</span><span class=p>)</span>
<span class=n>backend_sim</span> <span class=o>=</span> <span class=n>qsk</span><span class=o>.</span><span class=n>Aer</span><span class=o>.</span><span class=n>get_backend</span><span class=p>(</span><span class=s1>&#39;qasm_simulator&#39;</span><span class=p>)</span>
<span class=n>job</span> <span class=o>=</span> <span class=n>qsk</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=n>tomography_circuits</span><span class=p>,</span> <span class=n>backend_sim</span><span class=p>,</span> <span class=n>shots</span><span class=o>=</span><span class=mi>5000</span><span class=p>)</span>
<span class=n>result</span> <span class=o>=</span> <span class=n>job</span><span class=o>.</span><span class=n>result</span><span class=p>()</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>qiskit.ignis.verification.tomography</span> <span class=kn>import</span> <span class=n>StateTomographyFitter</span>

<span class=n>state_fitter</span> <span class=o>=</span> <span class=n>StateTomographyFitter</span><span class=p>(</span><span class=n>result</span><span class=p>,</span> <span class=n>tomography_circuits</span><span class=p>,</span> <span class=n>meas_basis</span><span class=o>=</span><span class=s1>&#39;Pauli&#39;</span><span class=p>)</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>density_matrix</span> <span class=o>=</span> <span class=n>state_fitter</span><span class=o>.</span><span class=n>fit</span><span class=p>(</span><span class=n>method</span><span class=o>=</span><span class=s1>&#39;lstsq&#39;</span><span class=p>)</span>
</code></pre></div><p>Let&rsquo;s define a helper function that plots the real and imaginary part as a grey scale image:</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>plot_density_matrix</span><span class=p>(</span><span class=n>DM</span><span class=p>):</span>
    <span class=s2>&#34;&#34;&#34;Helper function to plot density matrices.
</span><span class=s2>
</span><span class=s2>    Parameters
</span><span class=s2>    ----------------------------------------------
</span><span class=s2>    DM(np.array): Density Matrix.
</span><span class=s2>    
</span><span class=s2>    &#34;&#34;&#34;</span>
    <span class=kn>from</span> <span class=nn>matplotlib.ticker</span> <span class=kn>import</span> <span class=n>MaxNLocator</span>
    
    <span class=n>fig</span> <span class=o>=</span> <span class=n>plt</span><span class=o>.</span><span class=n>figure</span><span class=p>(</span><span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=mi>16</span><span class=p>,</span><span class=mi>10</span><span class=p>))</span>
    <span class=n>gs</span> <span class=o>=</span> <span class=n>fig</span><span class=o>.</span><span class=n>add_gridspec</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
    <span class=n>ax1</span> <span class=o>=</span> <span class=n>fig</span><span class=o>.</span><span class=n>add_subplot</span><span class=p>(</span><span class=n>gs</span><span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>])</span>
    <span class=n>ax2</span> <span class=o>=</span> <span class=n>fig</span><span class=o>.</span><span class=n>add_subplot</span><span class=p>(</span><span class=n>gs</span><span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>])</span>

    <span class=n>im</span> <span class=o>=</span> <span class=n>ax1</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>real</span><span class=p>(</span><span class=n>DM</span><span class=p>),</span> <span class=n>cmap</span><span class=o>=</span><span class=s1>&#39;Greys&#39;</span><span class=p>)</span>
    <span class=n>ax1</span><span class=o>.</span><span class=n>yaxis</span><span class=o>.</span><span class=n>set_major_locator</span><span class=p>(</span><span class=n>MaxNLocator</span><span class=p>(</span><span class=n>integer</span><span class=o>=</span><span class=bp>True</span><span class=p>))</span>
    <span class=n>ax1</span><span class=o>.</span><span class=n>xaxis</span><span class=o>.</span><span class=n>set_major_locator</span><span class=p>(</span><span class=n>MaxNLocator</span><span class=p>(</span><span class=n>integer</span><span class=o>=</span><span class=bp>True</span><span class=p>))</span>
    <span class=n>ax1</span><span class=o>.</span><span class=n>set_title</span><span class=p>(</span><span class=s1>&#39;Real Part&#39;</span><span class=p>,</span><span class=n>size</span><span class=o>=</span><span class=mi>16</span><span class=p>)</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>colorbar</span><span class=p>(</span><span class=n>im</span><span class=p>,</span> <span class=n>ax</span><span class=o>=</span><span class=n>ax1</span><span class=p>)</span>

    <span class=n>im</span> <span class=o>=</span> <span class=n>ax2</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>imag</span><span class=p>(</span><span class=n>DM</span><span class=p>),</span> <span class=n>cmap</span><span class=o>=</span><span class=s1>&#39;Greys&#39;</span><span class=p>)</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>colorbar</span><span class=p>(</span><span class=n>im</span><span class=p>,</span> <span class=n>ax</span><span class=o>=</span><span class=n>ax2</span><span class=p>)</span>
    <span class=n>ax2</span><span class=o>.</span><span class=n>yaxis</span><span class=o>.</span><span class=n>set_major_locator</span><span class=p>(</span><span class=n>MaxNLocator</span><span class=p>(</span><span class=n>integer</span><span class=o>=</span><span class=bp>True</span><span class=p>))</span>
    <span class=n>ax2</span><span class=o>.</span><span class=n>xaxis</span><span class=o>.</span><span class=n>set_major_locator</span><span class=p>(</span><span class=n>MaxNLocator</span><span class=p>(</span><span class=n>integer</span><span class=o>=</span><span class=bp>True</span><span class=p>))</span>
    <span class=n>ax2</span><span class=o>.</span><span class=n>set_title</span><span class=p>(</span><span class=s1>&#39;Imaginary Part&#39;</span><span class=p>,</span><span class=n>size</span><span class=o>=</span><span class=mi>16</span><span class=p>)</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>show</span><span class=p>()</span>
</code></pre></div><p>Ploting the density matrix, we see that there are states only on the first and last column (row), each column (row) represents a quantum state on the computational basis, for this case the states represented are $\left| 000 \right>$ and $\left| 111 \right>$ respectively. We can ignore the imaginary part, since is is only random noise.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>plot_density_matrix</span><span class=p>(</span><span class=n>density_matrix</span><span class=p>)</span>
</code></pre></div><p><img src=/n-blog/figures/2020-06-22-Tomography_files/2020-06-22-Tomography_26_0.svg alt="Density matrix"></p><p>The code for this post is on <a href=https://github.com/nahumsa/Introduction-to-IBM_Qiskit/blob/master/Notebooks/Tomography.ipynb>github</a>.</p><h1 id=references>References</h1><p>1 - <a href=http://research.physics.illinois.edu/QI/Photonics/tomography-files/tomo_chapter_2004.pdf>Altepeter et al - Quantum State Tomography</a></p><p>2 - <a href=https://qiskit.org/documentation/apidoc/verification.html#tomography>Qiskit Ignis Documentation</a></p><hr><h3>Version Information</h3><table><tr><th>Qiskit Software</th><th>Version</th></tr><tr><td>Qiskit</td><td>0.19.1</td></tr><tr><td>Terra</td><td>0.14.1</td></tr><tr><td>Aer</td><td>0.5.1</td></tr><tr><td>Ignis</td><td>0.3.0</td></tr><tr><td>Aqua</td><td>0.7.0</td></tr><tr><td>IBM Q Provider</td><td>0.7.0</td></tr><tr><th>System information</th></tr><tr><td>Python</td><td>3.7.3 | packaged by conda-forge | (default, Jul 1 2019, 21:52:21)
[GCC 7.3.0]</td></tr><tr><td>OS</td><td>Linux</td></tr><tr><td>CPUs</td><td>2</td></tr><tr><td>Memory (Gb)</td><td>7.664028167724609</td></tr><tr><td colspan=2>Sat May 23 17:14:48 2020 -03</td></tr></table></div><footer class="post-footer clearfix"><div class=share><a class=icon-twitter href="https://twitter.com/share?text=Quantum%20State%20Tomography&url=https%3a%2f%2fnahumsa.github.io%2fn-blog%2f2020-06-22-tomography%2f" onclick="window.open(this.href,'twitter-share','width=550,height=235');return false;" aria-label="Share on Twitter"><i class="fa fa-twitter" aria-hidden=true></i></a></div></footer></article></div></div></div><footer class=footer><div class=container><div class=site-title-wrapper><h1 class=site-title><a href=https://nahumsa.github.io/n-blog/>n-blog</a></h1><a class="button-square button-jump-top js-jump-top" href=# aria-label="Back to Top"><i class="fa fa-angle-up" aria-hidden=true></i></a></div><p class=footer-copyright><span>&copy; 2021 / Powered by <a href=https://gohugo.io/>Hugo</a></span></p><p class=footer-copyright><span><a href=https://github.com/roryg/ghostwriter>Ghostwriter theme</a> By <a href=http://jollygoodthemes.com>JollyGoodThemes</a></span>
<span>/ <a href=https://github.com/jbub/ghostwriter>Ported</a> to Hugo By <a href=https://github.com/jbub>jbub</a></span></p></div></footer><script src=https://nahumsa.github.io/n-blog/js/jquery-1.11.3.min.js></script><script src=https://nahumsa.github.io/n-blog/js/jquery.fitvids.js></script><script src=https://nahumsa.github.io/n-blog/js/scripts.js></script></body></html>