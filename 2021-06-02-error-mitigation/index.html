<!doctype html><html prefix="og: http://ogp.me/ns#"><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Digital zero noise extrapolation</title><meta name=description content="Digital zero noise extrapolation Zero noise extrapolation (ZNE) is a method introduced by K. Temme et al (2017) [1] and uses the error of the device in order to extrapolate a &ldquo;noiseless&rdquo; device. The issue for this approach is that it requires a pulse-level access to a quantum computer, which is not always possible for the user. In this work, they convert this approach systematically for a gate-level access. In this tutorial I will focus on the Gate Folding Method."><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=generator content="Hugo 0.83.1"><meta name=robots content="index,follow"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="Digital zero noise extrapolation"><meta property="og:description" content="Digital zero noise extrapolation Zero noise extrapolation (ZNE) is a method introduced by K. Temme et al (2017) [1] and uses the error of the device in order to extrapolate a &ldquo;noiseless&rdquo; device. The issue for this approach is that it requires a pulse-level access to a quantum computer, which is not always possible for the user. In this work, they convert this approach systematically for a gate-level access. In this tutorial I will focus on the Gate Folding Method."><meta property="og:type" content="article"><meta property="og:url" content="https://nahumsa.github.io/n-blog/2021-06-02-error-mitigation/"><link rel=stylesheet href=https://nahumsa.github.io/n-blog/dist/site.css><link rel=stylesheet href=https://nahumsa.github.io/n-blog/dist/syntax.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,400,600,700,300&subset=latin,cyrillic-ext,latin-ext,cyrillic"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous><link rel="shortcut icon" type=image/jpg href=https://nahumsa.github.io/n-blog/favicon.ico><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}},window.addEventListener('load',a=>{document.querySelectorAll("mjx-container").forEach(function(a){a.parentElement.classList+='has-jax'})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-170504520-1','auto'),ga('send','pageview'))</script><div id=wrapper><header class=site-header><div class=container><div class=site-title-wrapper><h1 class=site-title><a href=https://nahumsa.github.io/n-blog/>n-blog</a></h1><a class="button-square button-social hint--top" data-hint=Twitter aria-label=Twitter href=https://twitter.com/sa_nahum rel=me><i class="fa fa-twitter" aria-hidden=true></i></a>
<a class="button-square button-social hint--top" data-hint=Github aria-label=Github href=https://github.com/nahumsa rel=me><i class="fa fa-github-alt" aria-hidden=true></i></a>
<a class="button-square button-social hint--top" data-hint=Email aria-label="Send an Email" href=mailto:nahumsa@cbpf.br><i class="fa fa-envelope" aria-hidden=true></i></a></div><ul class=site-nav></ul></div></header><div id=container><div class=container><article class=post-container itemscope itemtype=http://schema.org/BlogPosting><header class=post-header><h1 class=post-title itemprop="name headline">Digital zero noise extrapolation</h1><p class="post-date post-line"><span>Published <time datetime=2021-06-02 itemprop=datePublished>Wed, Jun 2, 2021</time></span>
<span>by</span>
<span itemscope itemprop=author itemtype=https://schema.org/Person><span itemprop=name><a href=# itemprop=url rel=author>Nahum SÃ¡</a></span></span></p></header><div class="post-content clearfix" itemprop=articleBody><h1 id=digital-zero-noise-extrapolation>Digital zero noise extrapolation</h1><p>Zero noise extrapolation (ZNE) is a method introduced by K. Temme et al (2017) [1] and uses the error of the device in order to extrapolate a &ldquo;noiseless&rdquo; device. The issue for this approach is that it requires a pulse-level access to a quantum computer, which is not always possible for the user. In this work, they convert this approach systematically for a gate-level access. In this tutorial I will focus on the Gate Folding Method.</p><h1 id=core-idea>Core Idea</h1><p>The level of the noise on the system is parametrized by a dimensionless scale factor, $\alpha$. For $\alpha = 0$ we do not have the presence of noise, while for $\alpha = 1$ it is on the noise level of the real hardware. The scale factor could represent any re-scaling of a physical quantity which introduces noise.</p><p>We need to measure an expectation value which can be scaled regarding the noise which we call $E(\alpha)$ . By construction, $E(\alpha=1)$ represents the expectation value for the hardware that we are running and $E(\alpha=0)$ is the noiseless expectation value. The procedure is done in two steps:</p><ol><li><strong>Noise-Scaling:</strong> Measure $E(\alpha)$ for $m$ different values subjected to $\alpha \geq 1$.</li><li><strong>Extrapolation:</strong> Infer $E(0)$ from the data obtained in the previous step.</li></ol><h1 id=gate-folding>Gate Folding:</h1><p>We fold specific gates on the circuit such that it has the same effect to amplify noise. Let&rsquo;s consider $U = L_d \dots L_1$ such that $L_i$ represents gates or layers in the circuit. If we apply folding for a unique layer $L_i$ we would have:</p><p>$$U \rightarrow L_d \dots L_i (L_i^\dagger L_i)^n \dots L_i$$</p><p>Thus, the depth of the circuit would scale $d \rightarrow d(1+2n)$. We can also have a partial folding on this kind of setting. Let&rsquo;s define a subset, $S$, of indices from the set of all indices ${ 1, \dots, d }$ such that $s = |S|$. We can consider the following gate folding method:</p><p>$$ \forall j \in { 1, 2, \dots, d } \hspace{10pt}, \hspace{10pt} L_j = \begin{cases}
L_j \ (L_j^\dagger L_j)^n, & \text{if}\ j \not \in S \<br>L_j \ (L_j^\dagger L_j)^{n+1}, & \text{if} j \in S \end{cases}$$</p><p>There are three different method for creating the subset: from left, from right, and at random. We have the scaling on the number of gates just like unitary folding $d(2n +1) + 2s$. Thus, the scaling is the same $d \rightarrow \alpha d$, where:</p><p>$$\alpha = 1 + \frac{2k}{d} \hspace{10pt}, \hspace{10pt} k=1, 2, 3, \dots$$</p><p>And we can have the same procedure as the circuit folding to determine $n$ and $s$.</p><p>Or for every real $\alpha$, one can apply the procedure:</p><ol><li>Determine the closest integer $k$ to the real quantity $d(\alpha -1) / 2$.</li><li>Perform the integer division of $k$ by $d$. The quotient corresponds to $n$ while the remainder to $s$.</li><li>Apply $n$ integer folds and a final partial folding.</li></ol><h1 id=example>Example</h1><p>For this example, let&rsquo;s consider the noise model of a real device <code>ibmq_santiago</code>, and a simple circuit that the output should be $| 11 \rangle$. We would like to do the gate folding of the <code>cx</code> gate, since it is the gate that generates more noise.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>import</span> <span style=color:#0cf;font-weight:700>scipy</span> <span style=color:#069;font-weight:700>as</span> <span style=color:#0cf;font-weight:700>sp</span>
<span style=color:#069;font-weight:700>import</span> <span style=color:#0cf;font-weight:700>numpy</span> <span style=color:#069;font-weight:700>as</span> <span style=color:#0cf;font-weight:700>np</span>
<span style=color:#069;font-weight:700>import</span> <span style=color:#0cf;font-weight:700>matplotlib.pyplot</span> <span style=color:#069;font-weight:700>as</span> <span style=color:#0cf;font-weight:700>plt</span>
<span style=color:#069;font-weight:700>import</span> <span style=color:#0cf;font-weight:700>qiskit</span>

<span style=color:#069;font-weight:700>from</span> <span style=color:#0cf;font-weight:700>qiskit</span> <span style=color:#069;font-weight:700>import</span> QuantumCircuit, transpile, Aer, IBMQ
<span style=color:#069;font-weight:700>from</span> <span style=color:#0cf;font-weight:700>qiskit.providers.aer.noise</span> <span style=color:#069;font-weight:700>import</span> NoiseModel
<span style=color:#069;font-weight:700>from</span> <span style=color:#0cf;font-weight:700>qiskit.utils</span> <span style=color:#069;font-weight:700>import</span> QuantumInstance

<span style=color:#09f;font-style:italic># Loading your IBM Q account(s)</span>
provider <span style=color:#555>=</span> IBMQ<span style=color:#555>.</span>load_account()
</code></pre></div><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>run_obs</span>(qc, shots, backend_name<span style=color:#555>=</span><span style=color:#c30>&#39;ibmq_santiago&#39;</span>):
    <span style=color:#c30>&#34;&#34;&#34;Helper function to get the expected value of the
</span><span style=color:#c30>       | 11 &gt; state.
</span><span style=color:#c30>    &#34;&#34;&#34;</span>
    
    <span style=color:#09f;font-style:italic># Get device noise model</span>
    device <span style=color:#555>=</span> provider<span style=color:#555>.</span>get_backend(backend_name)
    noise_model <span style=color:#555>=</span> NoiseModel<span style=color:#555>.</span>from_backend(device)
    coupling_map <span style=color:#555>=</span> device<span style=color:#555>.</span>configuration()<span style=color:#555>.</span>coupling_map
    seed <span style=color:#555>=</span> <span style=color:#f60>42</span>

    <span style=color:#09f;font-style:italic># Define the backend</span>
    backend <span style=color:#555>=</span> QuantumInstance(
                            backend<span style=color:#555>=</span>Aer<span style=color:#555>.</span>get_backend(<span style=color:#c30>&#34;qasm_simulator&#34;</span>),
                            seed_transpiler<span style=color:#555>=</span>seed,
                            optimization_level<span style=color:#555>=</span><span style=color:#f60>1</span>,
                            noise_model<span style=color:#555>=</span>noise_model,
                            shots<span style=color:#555>=</span>shots,
                            )
    qc <span style=color:#555>=</span> qc<span style=color:#555>.</span>copy()
    qc<span style=color:#555>.</span>measure_all()
    counts <span style=color:#555>=</span> backend<span style=color:#555>.</span>execute(qc)<span style=color:#555>.</span>get_counts()
    <span style=color:#069;font-weight:700>return</span> counts[<span style=color:#c30>&#39;11&#39;</span>]<span style=color:#555>/</span>shots
</code></pre></div><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>qc <span style=color:#555>=</span> QuantumCircuit(<span style=color:#f60>2</span>)
qc<span style=color:#555>.</span>x(<span style=color:#f60>0</span>)
qc<span style=color:#555>.</span>cx(<span style=color:#f60>0</span>, <span style=color:#f60>1</span>)
qc<span style=color:#555>.</span>draw(<span style=color:#c30>&#39;mpl&#39;</span>)
</code></pre></div><p><img src=/n-blog/figures/2021-06-02-error-mitigation_files/2021-06-02-error-mitigation_6_0.png alt=png></p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>run_obs(qc, <span style=color:#f60>1000</span>)
</code></pre></div><pre><code>0.955
</code></pre><p>In order to fold the circuit in qiskit, we need to create an auxiliary circuit with the folded gates, for this I will base on another <a href=https://nahumsa.github.io/n-blog/2020-09-08-changing-circuits/>tutorial</a> that I did where I showed how to change the gate on an existing circuit.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>fold_cx</span>(qc, alpha):
    <span style=color:#c30>&#34;&#34;&#34; Fold the cx on the circuit given an alpha value.
</span><span style=color:#c30>    &#34;&#34;&#34;</span>
    d <span style=color:#555>=</span> qc<span style=color:#555>.</span>depth()
    k <span style=color:#555>=</span> np<span style=color:#555>.</span>ceil(d<span style=color:#555>*</span>(alpha <span style=color:#555>-</span> <span style=color:#f60>1</span>)<span style=color:#555>/</span><span style=color:#f60>2</span>)
    n <span style=color:#555>=</span> k<span style=color:#555>//</span>d
    s <span style=color:#555>=</span> k<span style=color:#555>%</span>d
    
    instructions <span style=color:#555>=</span> []
    <span style=color:#069;font-weight:700>for</span> instruction, qargs, cargs <span style=color:#000;font-weight:700>in</span> qc:
        <span style=color:#069;font-weight:700>if</span> instruction<span style=color:#555>.</span>name <span style=color:#555>==</span> <span style=color:#c30>&#39;cx&#39;</span>:
            instruction <span style=color:#555>=</span> qiskit<span style=color:#555>.</span>circuit<span style=color:#555>.</span>library<span style=color:#555>.</span>CXGate()
            barrier <span style=color:#555>=</span> qiskit<span style=color:#555>.</span>circuit<span style=color:#555>.</span>library<span style=color:#555>.</span>Barrier(<span style=color:#366>len</span>(qc))
            
            instructions<span style=color:#555>.</span>append((instruction, qargs, cargs))
            instructions<span style=color:#555>.</span>append((barrier, qargs, cargs))
            <span style=color:#069;font-weight:700>for</span> _ <span style=color:#000;font-weight:700>in</span> <span style=color:#366>range</span>(<span style=color:#f60>2</span><span style=color:#555>*</span><span style=color:#366>int</span>(n <span style=color:#555>+</span> s)):
                instructions<span style=color:#555>.</span>append((instruction, qargs, cargs))
                instructions<span style=color:#555>.</span>append((barrier, qargs, cargs))
                
        
        <span style=color:#069;font-weight:700>else</span>:
            instructions<span style=color:#555>.</span>append((instruction, qargs, cargs))
    
    folded_qc <span style=color:#555>=</span> qc<span style=color:#555>.</span>copy()
    folded_qc<span style=color:#555>.</span>data <span style=color:#555>=</span> instructions
    <span style=color:#069;font-weight:700>return</span> folded_qc
</code></pre></div><p>Let&rsquo;s collect the circuit given the alpha value.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>alpha_list <span style=color:#555>=</span> [<span style=color:#f60>1</span>, <span style=color:#f60>2</span>, <span style=color:#f60>5</span>, <span style=color:#f60>7</span>, <span style=color:#f60>9</span>, <span style=color:#f60>11</span>]
folds <span style=color:#555>=</span> []
<span style=color:#069;font-weight:700>for</span> alpha <span style=color:#000;font-weight:700>in</span> alpha_list:
    folds<span style=color:#555>.</span>append(fold_cx(qc, alpha))
</code></pre></div><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>expected_vals <span style=color:#555>=</span> []
<span style=color:#069;font-weight:700>for</span> i <span style=color:#000;font-weight:700>in</span> <span style=color:#366>range</span>(<span style=color:#366>len</span>(alpha_list)):
    expected_vals<span style=color:#555>.</span>append(run_obs(folds[i], shots<span style=color:#555>=</span><span style=color:#f60>1000</span>))
</code></pre></div><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>print</span>(f<span style=color:#c30>&#34;Alphas: {alpha_list}</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>Expected values{expected_vals}&#34;</span>)
</code></pre></div><pre><code>Alphas: [1, 2, 5, 7, 9, 11]
Expected values[0.961, 0.941, 0.911, 0.907, 0.87, 0.849]
</code></pre><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>plt<span style=color:#555>.</span>plot(alpha_list, expected_vals, <span style=color:#c30>&#39;o&#39;</span>)
plt<span style=color:#555>.</span>xlabel(<span style=color:#c30>r</span><span style=color:#c30>&#34;$\alpha$&#34;</span>, size<span style=color:#555>=</span><span style=color:#f60>14</span>)
plt<span style=color:#555>.</span>ylabel(<span style=color:#c30>r</span><span style=color:#c30>&#34;E($\alpha$)&#34;</span>, size<span style=color:#555>=</span><span style=color:#f60>14</span>)
plt<span style=color:#555>.</span>show()
</code></pre></div><p><img src=/n-blog/figures/2021-06-02-error-mitigation_files/2021-06-02-error-mitigation_14_0.png alt=png></p><h2 id=extrapolate-e0>Extrapolate E(0)</h2><p>Now that we&rsquo;ve colected all $\alpha$ values and $E(\alpha)$ values we can extrapolate the &ldquo;noiseless&rdquo; regime. For this case I will use linear extrapolation.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>linear</span>(x, a, b):
    <span style=color:#c30>&#34;&#34;&#34;Linear fit
</span><span style=color:#c30>    &#34;&#34;&#34;</span>
    <span style=color:#069;font-weight:700>return</span> a<span style=color:#555>*</span>x <span style=color:#555>+</span> b

y <span style=color:#555>=</span> expected_vals
x <span style=color:#555>=</span> alpha_list
x, y <span style=color:#555>=</span> np<span style=color:#555>.</span>array(x), np<span style=color:#555>.</span>array(y)

popt, _ <span style=color:#555>=</span> sp<span style=color:#555>.</span>optimize<span style=color:#555>.</span>curve_fit(linear, x, y)
<span style=color:#069;font-weight:700>print</span>(<span style=color:#c30>&#34;Mitigated expectation value:&#34;</span>, np<span style=color:#555>.</span>round(popt[<span style=color:#f60>1</span>],<span style=color:#f60>3</span>))
<span style=color:#069;font-weight:700>print</span>(<span style=color:#c30>&#34;Unmitigated expectation value:&#34;</span>, expected_vals[<span style=color:#f60>0</span>])
</code></pre></div><pre><code>Mitigated expectation value: 0.968
Unmitigated expectation value: 0.961
</code></pre><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>print</span>(<span style=color:#c30>&#34;Absolute error with mitigation:&#34;</span>, np<span style=color:#555>.</span>round(np<span style=color:#555>.</span>abs(<span style=color:#f60>1</span> <span style=color:#555>-</span> popt[<span style=color:#f60>1</span>]), <span style=color:#f60>3</span>))
<span style=color:#069;font-weight:700>print</span>(<span style=color:#c30>&#34;Absolute error without mitigation:&#34;</span>, np<span style=color:#555>.</span>round(np<span style=color:#555>.</span>abs(<span style=color:#f60>1</span> <span style=color:#555>-</span> expected_vals[<span style=color:#f60>0</span>]), <span style=color:#f60>3</span>))
</code></pre></div><pre><code>Absolute error with mitigation: 0.032
Absolute error without mitigation: 0.039
</code></pre><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>plt<span style=color:#555>.</span>plot(alpha_list, expected_vals, <span style=color:#c30>&#39;o&#39;</span>)
plt<span style=color:#555>.</span>plot(<span style=color:#f60>0</span>, popt[<span style=color:#f60>1</span>], <span style=color:#c30>&#39;*&#39;</span>, label<span style=color:#555>=</span><span style=color:#c30>&#34;mitigated&#34;</span>)
plt<span style=color:#555>.</span>xlabel(<span style=color:#c30>r</span><span style=color:#c30>&#34;$\alpha$&#34;</span>, size<span style=color:#555>=</span><span style=color:#f60>14</span>)
plt<span style=color:#555>.</span>ylabel(<span style=color:#c30>r</span><span style=color:#c30>&#34;E($\alpha$)&#34;</span>, size<span style=color:#555>=</span><span style=color:#f60>14</span>)
plt<span style=color:#555>.</span>legend()
plt<span style=color:#555>.</span>show()
</code></pre></div><p><img src=/n-blog/figures/2021-06-02-error-mitigation_files/2021-06-02-error-mitigation_18_0.png alt=png></p><p>We can see that we got closer to the ideal value of 1, and got a better result than what we would get from the device without error mitigation!</p><h1 id=references>References</h1><ul><li><p>[1] - Error mitigation for short-depth quantum circuits - Kristan Temme, Sergey Bravyi, Jay M. Gambetta - <a href=https://arxiv.org/abs/1612.02058>Arxiv</a></p></li><li><p>[2] - Digital zero noise extrapolation for quantum error mitigation -Tudor Giurgica-Tiron, Yousef Hindy, Ryan LaRose, Andrea Mari, William J. Zeng - <a href=https://arxiv.org/abs/2005.10921>Arxiv</a></p></li></ul></div><footer class="post-footer clearfix"><div class=share><a class=icon-twitter href="https://twitter.com/share?text=Digital%20zero%20noise%20extrapolation&url=https%3a%2f%2fnahumsa.github.io%2fn-blog%2f2021-06-02-error-mitigation%2f" onclick="return window.open(this.href,'twitter-share','width=550,height=235'),!1" aria-label="Share on Twitter"><i class="fa fa-twitter" aria-hidden=true></i></a></div></footer></article></div></div></div><footer class=footer><div class=container><div class=site-title-wrapper><h1 class=site-title><a href=https://nahumsa.github.io/n-blog/>n-blog</a></h1><a class="button-square button-jump-top js-jump-top" href=# aria-label="Back to Top"><i class="fa fa-angle-up" aria-hidden=true></i></a></div><p class=footer-copyright><span>&copy; 2021 / Powered by <a href=https://gohugo.io/>Hugo</a></span></p><p class=footer-copyright><span><a href=https://github.com/roryg/ghostwriter>Ghostwriter theme</a> By <a href=http://jollygoodthemes.com>JollyGoodThemes</a></span>
<span>/ <a href=https://github.com/jbub/ghostwriter>Ported</a> to Hugo By <a href=https://github.com/jbub>jbub</a></span></p></div></footer><script src=https://nahumsa.github.io/n-blog/js/jquery-1.11.3.min.js></script><script src=https://nahumsa.github.io/n-blog/js/jquery.fitvids.js></script><script src=https://nahumsa.github.io/n-blog/js/scripts.js></script></body></html>