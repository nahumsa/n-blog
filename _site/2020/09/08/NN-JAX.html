<!DOCTYPE html>
<html>

  <head>
  
    





  

  <meta charset="utf-8">  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" href="/n-blog/assets/images/favicon.ico" type="image/png" />    
  <title>Creating a simple Neural Network in JAX</title>
  
  <meta name="description" content="You can run this on colab: ">
  <link rel="stylesheet" href="/n-blog/css/main.css">
  <link rel="canonical" href="http://localhost:4000/n-blog/2020/09/08/NN-JAX.html">
  <link rel="alternate" type="application/rss+xml" title="N-Blog" href="http://localhost:4000/n-blog/feed.xml">
  <meta name="google-site-verification" content="fqeWQrskF38vWHtVyzcKHELwEGZiP9JesnM-sXbBu9Y" />
  <!-- For Latex -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-170504520-1', 'auto');
    ga('send', 'pageview');
  </script>
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    <a class="site-title" href="/n-blog/">N-Blog</a>

    
    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
      <nav class="site-nav">
        <a class="page-link" href="/n-blog/about/">&#x1f4ee; About</a>
      </nav>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Creating a simple Neural Network in JAX</h1>
    <p class="post-meta"><time datetime="2020-09-08T17:00:00-03:00" itemprop="datePublished">Sep 8, 2020</time></p>
    <span>[
      
        
        <a href="/n-blog/tag/Neural-Networks"><code class="highligher-rouge"><nobr>Neural-Networks</nobr></code>&nbsp;</a>
      
    ]</span>
    
  </header>
  
  <div class="post-content" itemprop="articleBody">
    <p>You can run this on colab: <a href="https://colab.research.google.com/github/nahumsa/JAX/blob/master/Simple%20NN%20JAX.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab" /></a></p>

<h1 id="creating-a-neural-network-in-jax">Creating a neural network in JAX</h1>

<p><a href="https://github.com/google/jax">JAX</a> is a new python library that offers autograd and XLA, leading to high-performance machine learning, and numeric research. JAX works just as numpy and using jit (just in time) compilation, you can have high-performance without going to low level languages. One awesome thing is that, just as tensorflow, you can use GPUs and TPUs for acceleration.</p>

<p>In this post my aim is to build and train a simple Convolutional Neural Network using JAX.</p>

<h1 id="1-using-vmap-grad-and-jit">1) Using vmap, grad and jit</h1>

<h2 id="11-jit">1.1) jit</h2>

<p>In order to speed up your code, you can use the jit decorator, <code class="highlighter-rouge">@jit</code> which will cached your operation. Let’s compare the speed with and without jit. This example is taken from the <a href="https://jax.readthedocs.io/en/latest/notebooks/quickstart.html">Jax Quickstart Guide</a></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from jax import random
import jax.numpy as np

def selu(x, alpha=1.67, lmbda=1.05):
  return lmbda * np.where(x &gt; 0, x, alpha * np.exp(x) - alpha)

key = random.PRNGKey(0)
x = random.normal(key, (1000000,))
%timeit selu(x).block_until_ready()
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from jax import jit
selu_jit = jit(selu)
%timeit selu_jit(x).block_until_ready()
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The slowest run took 23.63 times longer than the fastest. This could mean that an intermediate result is being cached.
1000 loops, best of 3: 1.46 ms per loop
</code></pre></div></div>

<p>We see that with jit, we go 6 ms faster than without jit. Another remark is that we put the <code class="highlighter-rouge">block_until_ready()</code> method because asynchronous update by default.</p>

<h2 id="12-grad">1.2) grad</h2>

<p>Taking the gradient in JAX is pretty easy, you just need to call the <code class="highlighter-rouge">grad</code> function from the JAX library. Let’s begin with a simple example that is calculating the grad of $x^2$. From calculus, we know that:</p>

<script type="math/tex; mode=display">\frac{\partial x^2}{\partial x} = 2 x</script>

<script type="math/tex; mode=display">\frac{\partial^2 x^2}{\partial x^2} = 2</script>

<script type="math/tex; mode=display">\frac{\partial^3 x^2}{\partial x^3} = 0</script>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from jax import grad
square = lambda x: np.square(x)

grad_square = grad(square)
grad_grad_square = grad(grad(square))
grad_grad_grad_square = grad(grad(grad(square)))
print(f"grad 2² = ", grad_square(2.))
print(f"grad grad 2² = ", grad_grad_square(2.))
print(f"grad grad grad 2² = ", grad_grad_grad_square(2.))
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>grad 2² =  4.0
grad grad 2² =  2.0
grad grad grad 2² =  0.0
</code></pre></div></div>

<h2 id="13-vmap">1.3) vmap</h2>

<p>vmap, or vectorizing map, maps a function along array axes, having better performance mainly when is composed with jit. Let’s apply this for matrix-vector products.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mat = random.normal(key, (150, 100))
batched_x = random.normal(key, (10, 100))

def apply_matrix(v):
  return np.dot(mat, v)
</code></pre></div></div>

<p>In order to batch naively, we can use a for loop to batch.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def naively_batched_apply_matrix(v_batched):
  return np.stack([apply_matrix(v) for v in v_batched])

print('Naively batched')
%timeit naively_batched_apply_matrix(batched_x).block_until_ready()
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Naively batched
100 loops, best of 3: 4.63 ms per loop
</code></pre></div></div>

<p>Now we can use vmap to batch our multiplication</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from jax import vmap

@jit
def vmap_batched_apply_matrix(v_batched):
  return vmap(apply_matrix)(v_batched)

print('Auto-vectorized with vmap')
%timeit vmap_batched_apply_matrix(batched_x).block_until_ready()
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Auto-vectorized with vmap
The slowest run took 57.86 times longer than the fastest. This could mean that an intermediate result is being cached.
1000 loops, best of 3: 281 µs per loop
</code></pre></div></div>

<p>Now we can apply this for creating neural networks.</p>

<h1 id="2--using-stax-for-convolutional-neural-networks">2 ) Using STAX for Convolutional Neural Networks</h1>

<p>As a first example, we shall use MNIST (as always) to train a convolutional neural network using stax. It is important to import the original numpy package for shuffling and random generation.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import jax.numpy as np
import numpy as onp
</code></pre></div></div>

<p>Let’s import MNIST using <code class="highlighter-rouge">tensorflow_datasets</code> and transform the data into a np.array.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import tensorflow_datasets as tfds
data_dir = '/tmp/tfds'
mnist_data, info = tfds.load(name="mnist", batch_size=-1, data_dir=data_dir, with_info=True)
mnist_data = tfds.as_numpy(mnist_data)
train_data, test_data = mnist_data['train'], mnist_data['test']
num_labels = info.features['label'].num_classes
h, w, c = info.features['image'].shape
num_pixels = h * w * c

from IPython.display import clear_output
clear_output()
</code></pre></div></div>

<p>Let’s split the training and test dataset and one hot encode the labels of our data.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def one_hot(x, k, dtype=np.float32):
    """Create a one-hot encoding of x of size k """
    return np.array(x[:, None] == np.arange(k), dtype)

# Full train set
train_images, train_labels = train_data['image'], train_data['label']
train_images = np.array(np.moveaxis(train_images, -1, 1), dtype=np.float32)

train_labels = one_hot(train_labels, num_labels)

# Full test set
test_images, test_labels = test_data['image'], test_data['label']
test_images = np.array(np.moveaxis(test_images, -1, 1), dtype=np.float32)
test_labels = one_hot(test_labels, num_labels)
</code></pre></div></div>

<p>Now we need to construct a data_stream which will generate our batch data, this data stream will shuffle the training dataset. First let’s define the batch size and how many batches should be used for going through all the data.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>batch_size = 128
num_train = train_images.shape[0]
num_complete_batches, leftover = divmod(num_train, batch_size)
num_batches = num_complete_batches + bool(leftover)
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def data_stream():
  """Creates a data stream with a predifined batch size.
  """
  rng = onp.random.RandomState(0)
  while True:
    perm = rng.permutation(num_train)
    for i in range(num_batches):
      batch_idx = perm[i * batch_size: (i + 1)*batch_size]
      yield train_images[batch_idx], train_labels[batch_idx]

batches = data_stream()
</code></pre></div></div>

<p>Now let’s construct our network, we will contruct a simple convolutional neural network with 4 convoclutional blocks with batchnorm and relu and a dense softmax as output of the neural network.</p>

<p>First you define your neural network using <code class="highlighter-rouge">stax.serial</code> and get the init_fun and conv_net, the former is the initialization function of the network and the latter is your neural network which we will use on the update function.</p>

<p>After defining our network, we initialize it using the init function and we get our network parameters which we will optimize.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from jax.experimental import stax
from jax import random
from jax.experimental.stax import (BatchNorm, Conv, Dense, Flatten,
                                   Relu, LogSoftmax)

init_fun, conv_net = stax.serial(Conv(32, (5, 5), (2, 2), padding="SAME"),
                                 BatchNorm(), Relu,
                                 Conv(32, (5, 5), (2, 2), padding="SAME"),
                                 BatchNorm(), Relu,
                                 Conv(10, (3, 3), (2, 2), padding="SAME"),
                                 BatchNorm(), Relu,
                                 Conv(10, (3, 3), (2, 2), padding="SAME"), Relu,
                                 Flatten,
                                 Dense(num_labels),
                                 LogSoftmax)


key = random.PRNGKey(0)
_, params = init_fun(key, (-1,) + train_images.shape[1:]) # -1 for varying batch size
</code></pre></div></div>

<p>Now let’s define the accuracy and the loss function.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def accuracy(params, batch):
  """ Calculates the accuracy in a batch.

  Args:
    params : Neural network parameters.
    batch : Batch consisting of images and labels.
  
  Outputs:
    (float) : Mean value of the accuracy.
  """

  # Unpack the input and targets
  inputs, targets = batch
  
  # Get the label of the one-hot encoded target
  target_class = np.argmax(targets, axis=1)
  
  # Predict the class of the batch of images using 
  # the conv_net defined before
  predicted_class = np.argmax(conv_net(params, inputs), axis=1)

  return np.mean(predicted_class == target_class)
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def loss(params, batch):
  """ Cross entropy loss.
  Args:
    params : Neural network parameters.
    batch : Batch consisting of images and labels.
  
  Outputs:
    (float) : Sum of the cross entropy loss over the batch.
  """
  # Unpack the input and targets
  images, targets = batch
  # precdict the class using the neural network
  preds = conv_net(params, images)

  return -np.sum(preds * targets)
</code></pre></div></div>

<p>Let’s define which optimizer we shall use for training our neural network. Here we shall select the adam optimizer and initialize the optimizer with our neural network parameters.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from jax.experimental import optimizers

step_size = 1e-3
opt_init, opt_update, get_params = optimizers.adam(step_size)
opt_state = opt_init(params)
</code></pre></div></div>

<p>In order to create our update function for the network, we shall use the <code class="highlighter-rouge">jit</code> decorator to make things faster.</p>

<p>Inside the update function we take the value and gradient of the loss function given for the given parameters and the dataset and update our parameters using the optimizer.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from jax import jit, value_and_grad

@jit
def update(params, x, y, opt_state):
    """ Compute the gradient for a batch and update the parameters """
    
    # Take the gradient and evaluate the loss function
    value, grads = value_and_grad(loss)(params, (x, y))
    
    # Update the network using the gradient taken
    opt_state = opt_update(0, grads, opt_state)
    
    return get_params(opt_state), opt_state, value
</code></pre></div></div>

<p>Now we shall create a training loop for the neural network, we run the loop for a number of epochs and run on all data using the data_stream that we defined before.</p>

<p>Then we record the loss and accuracy for each epoch.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from tqdm.notebook import tqdm
train_acc, test_acc = [], []
train_loss, val_loss = [], []


num_epochs = 10

for epoch in tqdm(range(num_epochs)): 
  for _ in range(num_batches):
    x, y = next(batches)    
    params, opt_state, _loss = update(params, x, y, opt_state)
    

  # Update parameters of the Network
  params = get_params(opt_state)

  train_loss.append(np.mean(loss(params, (train_images, train_labels)))/len(train_images))
  val_loss.append(loss(params, (test_images, test_labels))/len(test_images))

  train_acc_epoch = accuracy(params, (train_images, train_labels))
  test_acc_epoch = accuracy(params, (test_images, test_labels))
  
  train_acc.append(train_acc_epoch)
  test_acc.append(test_acc_epoch)
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>epochs = range(num_epochs)

fig = plt.figure(figsize=(12,6))
gs = fig.add_gridspec(1, 2)
ax1 = fig.add_subplot(gs[0, 0])
ax2 = fig.add_subplot(gs[0, 1])

ax1.plot(epochs, train_loss, 'r', label='Training')
ax1.plot(epochs, val_loss, 'b', label='Validation')
ax1.set_xlabel('Epochs', size=16)
ax1.set_ylabel('Loss', size=16)
ax1.legend()

ax2.plot(epochs, train_acc, 'r', label='Training')
ax2.plot(epochs, test_acc, 'b', label='Validation')
ax2.set_xlabel('Epochs', size=16)
ax2.set_ylabel('Accuracy', size=16)
ax2.legend()
plt.show()
</code></pre></div></div>

<p style="text-align:center;"><img src="/n-blog/assets/2020-09-25-NN-JAX_files/2020-09-25-NN-JAX_35_0.png" /></p>

<p>Now we have successfully created and trained a neural network using JAX!</p>

<hr />

<h1 id="references">References</h1>

<ul>
  <li>
    <p><a href="https://roberttlange.github.io/posts/2020/03/blog-post-10/">Robert Lang Blog</a></p>
  </li>
  <li>
    <p><a href="https://jax.readthedocs.io/en/stable/notebooks/quickstart.html">JAX Quickstart</a></p>
  </li>
  <li>
    <p><a href="https://github.com/google/jax/blob/master/docs/notebooks/neural_network_with_tfds_data.ipynb">Training a Simple Neural Network, with tensorflow/datasets Data Loading</a></p>
  </li>
</ul>

  </div>

</article>

      </div>
    </div>    

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">N-Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>N-Blog</li>
          <li><a href="mailto:nahumsa@cbpf.br">nahumsa@cbpf.br</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/nahumsa"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">nahumsa</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/sa_nahum"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">sa_nahum</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Here I will share thoughts and ideas about Machine Learning  and Quantum Computing.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
