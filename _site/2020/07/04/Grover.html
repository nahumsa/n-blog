<!DOCTYPE html>
<html>

  <head>
  
    





  

  <meta charset="utf-8">  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" href="/n-blog/assets/images/favicon.ico" type="image/png" />    
  <title>Grover Algorithm</title>
  
  <meta name="description" content="Grover’s Algorithm">
  <link rel="stylesheet" href="/n-blog/css/main.css">
  <link rel="canonical" href="http://localhost:4000/n-blog/2020/07/04/Grover.html">
  <link rel="alternate" type="application/rss+xml" title="N-Blog" href="http://localhost:4000/n-blog/feed.xml">
  <meta name="google-site-verification" content="fqeWQrskF38vWHtVyzcKHELwEGZiP9JesnM-sXbBu9Y" />
  <!-- For Latex -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-170504520-1', 'auto');
    ga('send', 'pageview');
  </script>
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    <a class="site-title" href="/n-blog/">N-Blog</a>

    
    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
      <nav class="site-nav">
        <a class="page-link" href="/n-blog/about/">&#x1f4ee; About</a>
      </nav>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Grover Algorithm</h1>
    <p class="post-meta"><time datetime="2020-07-04T15:00:00-03:00" itemprop="datePublished">Jul 4, 2020</time></p>
    <span>[
      
        
        <a href="/n-blog/tag/Quantum-Computing Qiskit Tutorial Quantum-Algorithm"><code class="highligher-rouge"><nobr>Quantum-Computing Qiskit Tutorial Quantum-Algorithm</nobr></code>&nbsp;</a>
      
    ]</span>
    
  </header>
  
  <div class="post-content" itemprop="articleBody">
    <h1 id="grovers-algorithm">Grover’s Algorithm</h1>

<h1 id="1-introduction">1) Introduction</h1>

<p>Grover’s algorithm is useful for searching an unstructured database with N elements. For instance,you have a phone number and want to find the corresponding name associated to this phone number, since it is unstructured you need to check every element (in the worst case scenario), but if you have the solution it is easy to check, this shows that the problem is NP.</p>

<p>In order to show Grover’s algorithm we need to rephrase as an oracle problem: Labelling each element of the database <script type="math/tex">\{0,1, \dots, N-1 \}</script> and <script type="math/tex">x_0</script> the unknown marked item. The oracle <script type="math/tex">f</script> computes the following binary function:</p>

<script type="math/tex; mode=display">% <![CDATA[
f: \{0,1 \}^N \rightarrow \{0,1 \} \hspace{1em} , \hspace{1em} \mathrm{with} \hspace{2em} f(x) = \begin{cases}
    1, & \text{if } x=x_0\\
    0, & \text{otherwise}
\end{cases} %]]></script>

<p>For a classical computer, the probability to find <script type="math/tex">x_0</script> is <script type="math/tex">\frac{1}{N}</script> , so to find <script type="math/tex">x_0</script> with probability <script type="math/tex">p</script> is needed <script type="math/tex">p N = \mathcal{O}(N)</script> oracle queries. Grovers showed that on a quantum computer we can have a quadratic speedup, then we will need <script type="math/tex">\mathcal{O}(\sqrt{N})</script> queries. This is not massive, but we can compare this speedup with the breakthrough that Fast Fourier Transform(FFT) did for signalling processing.</p>

<h1 id="2-general-algorithm">2) General Algorithm</h1>

<h2 id="21-algorithm">2.1) Algorithm</h2>

<p>Here we suppose a quantum oracle with the ability to recognize solutions to the search problem. This recognition is signaled by making use of an oracle qubit. More precisely:</p>

<script type="math/tex; mode=display">| x \rangle | q \rangle  \xrightarrow[]{O} | x \rangle | q \oplus f(x) \rangle</script>

<p>The oracle <script type="math/tex">| q \rangle</script> is a single qubit which is flipped if <script type="math/tex">f(x) = 1</script> and is unchanged otherwise. We can check if whether x is a solution by preparing 
<script type="math/tex">| x \rangle| 0 \rangle</script>
and seeing if the oracle qubit flips when using the oracle.</p>

<p>It is common to use 
<script type="math/tex">| q \rangle = \frac{1}{\sqrt{2}} \big( | 0 \rangle - | 1 \rangle \big)</script>
. The action of the oracle is:</p>

<script type="math/tex; mode=display">| x \rangle \frac{1}{\sqrt{2}} \big( | 0 \rangle - | 1 \rangle \big) \xrightarrow[]{O} (-1)^{f(x)} | x \rangle \frac{1}{\sqrt{2}} \big( | 0 \rangle - | 1 \rangle \big)</script>

<p>Using this type of oracle qubit it remains the same when applying the oracle and can be omitted from the following steps of the algorithm. With this convention:</p>

<script type="math/tex; mode=display">| x \rangle \xrightarrow[]{O} (-1)^{f(x)}| x \rangle</script>

<p>The oracle marks the solution by shifting the phase. For a N item search problem with M solutions, we need to apply the search oracle <script type="math/tex">O(\sqrt{\frac{N}{M}})</script> times in order to obtain the solution.</p>

<p>The algorithm with the Grover operator G is the following:</p>

<p style="text-align:center;"><img src="/n-blog/assets/2020-07-04-Grover_files/GroverCircuit.jpg" /></p>
<p style="text-align:center;">Figure 1: Circuit for the Grover Algorithm, the unitary G are called Grover Iterations or Grover Operator</p>

<p>The algorithm begins with 
<script type="math/tex">| 0 \rangle^{\otimes N}</script>
. The Haddamard transform put in the equal superposition state, which we call 
<script type="math/tex">| \psi \rangle</script>
:</p>

<script type="math/tex; mode=display">| \psi \rangle = \frac{1}{\sqrt{N}} \sum_{x=0}^{N-1} | x \rangle</script>

<p>The algorithm consists of repeated applications of the grover operator G. This subroutine can be broken up into 4 steps:</p>

<p>(1): Apply the oracle O.</p>

<p>(2): Apply the Haddamard transform <script type="math/tex">H^{\otimes N}</script>.</p>

<p>(3): Perform a conditional phase shift on the computer, with every computational basis state except 
<script type="math/tex">| 0 \rangle</script>
 receiving a phase shift of -1: 
 <script type="math/tex">| x \rangle \xrightarrow[]{M} -(-1)^{\delta_{x0}} | x \rangle</script>
 .</p>

<p>(4): Apply the Haddamard transform <script type="math/tex">H^{\otimes N}</script>.</p>

<p>The circuit for the Grover operator is the following:</p>

<p style="text-align:center;"><img src="/n-blog/assets/2020-07-04-Grover_files/GroverOperator.jpg" /></p>
<p style="text-align:center;">Figure 2: Circuit for the Grover Operator G.</p>

<p>This operator for the conditional phase shift on step (2) is simply 
<script type="math/tex">M = 2 | 0 \rangle \langle 0 | - I</script>
, because we have:</p>

<script type="math/tex; mode=display">% <![CDATA[
M = \begin{pmatrix}
    2-1 & 0  & \dots & 0 \\
    0   & -1 & \dots & 0 \\
    \vdots & \ddots & \vdots & \vdots \\
    0 & \dots & 0 & -1 
    \end{pmatrix} %]]></script>

<p>Steps 2 and 4 needs <script type="math/tex">n=\log(N)</script> operations each. Step 3, the conditional phase shift, can be implemented using <script type="math/tex">O(n)</script> gates. But the cost of the Oracle depends on the application, on the bright side, we only need to call the oracle once. The steps 2,3,4 combined are:</p>

<script type="math/tex; mode=display">H^{\otimes n} \big( 2 | 0 \rangle \langle 0 | - I \big) H^{\otimes n} = 2 | \psi \rangle \langle \psi |</script>

<p>Where 
<script type="math/tex">| \psi \rangle</script> 
is the weighted superposition. Thus: 
<script type="math/tex">G = \big( 2| \psi \rangle \langle \psi | - I \big) O</script>
. Let’s see how the operator 
<script type="math/tex">2| \psi \rangle \langle \psi | - I</script>
acts on an arbitrary state: 
<script type="math/tex">| \eta \rangle = \sum_k \alpha_k | k \rangle</script>
:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{split}
    \bigg( 2| \psi \rangle \langle \psi | - I \bigg) | \eta \rangle & = \bigg( 2| \psi \rangle \langle \psi | - I \bigg) \sum_k \alpha_k |k \rangle \\ 
    & = \bigg[ \frac{2}{N} \sum_{x,y} | x \rangle \langle y | - I \bigg] \sum_k \alpha_k |k \rangle = \frac{2}{N} \sum_{x,y,k} \alpha_k | x \rangle \langle y | | k \rangle - \sum_k \alpha_k | k \rangle \\
    & = \frac{2}{N} \sum_{x,k} \alpha_k | x \rangle - | \eta  \rangle  = 2 \overbrace{\sum_{k} \frac{\alpha_k}{N}}^{\equiv \langle \alpha \rangle} \sum_x | x \rangle - | \eta \rangle \\
    & = 2 \sum_x \langle \alpha \rangle | x \rangle - \sum_k \alpha_k | k \rangle = \sum_k \bigg[ - \alpha_k + 2 \langle \alpha \rangle \bigg] | k \rangle
\end{split} %]]></script>

<p>For this reason, sometimes this operator is called the inversion about the mean.</p>

<h2 id="22-geometric-representation">2.2) Geometric Representation</h2>

<p>We can have a geometric visualization of the algorithm that will help us to show that the algorithm needs <script type="math/tex">O(\sqrt{N})</script> gates, for this we want to show that the Grover Operator can be regarded as a rotation in the 2D space spanned by the starting vector 
<script type="math/tex">|\psi \rangle</script> 
and the state with the uniform superposition of solutions to the search problem. We adopt the convention <script type="math/tex">\sum_x^{'}</script> to be the sum over all x which are solutions to the search problem, and <script type="math/tex">\sum_x''</script> to be the sum over all x which are not solutions. We also define the normalized states:</p>

<script type="math/tex; mode=display">| \alpha \rangle \equiv \frac{1}{\sqrt{N-M}} \sum_x '' |x \rangle \ \ \ \ | \beta \rangle \equiv \frac{1}{\sqrt{M}} \sum_x ' | x \rangle</script>

<p>We can rewrite 
<script type="math/tex">| \psi \rangle</script> 
in terms of 
<script type="math/tex">| \alpha \rangle</script>
 and 
 <script type="math/tex">| \beta \rangle</script>
 :</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{split}
    | \psi \rangle & =  \frac{1}{\sqrt{N}} \sum_x | x \rangle = \frac{1}{\sqrt{N}} \bigg( \sum_x ' | x \rangle + \sum_x '' | x \rangle \bigg)  \\
     & = \frac{1}{\sqrt{N}} \bigg( \sqrt{M} | \beta \rangle + \sqrt{N-M} | \alpha \rangle \bigg) \\
     & = \sqrt{\frac{N-M}{N}} | \alpha \rangle + \sqrt{\frac{M}{N}} | \beta \rangle
    \end{split} %]]></script>

<p>So that the initial state is spanned by 
<script type="math/tex">| \alpha \rangle</script> 
and 
<script type="math/tex">| \beta \rangle</script>
. The effect of G can be understood in a beautiful way by showing that the oracle <script type="math/tex">O</script> performs a reflection about the vector 
<script type="math/tex">| \alpha \rangle</script> 
and <script type="math/tex">| \beta \rangle</script>
. That is:</p>

<script type="math/tex; mode=display">O ( a |\alpha \rangle + b | \beta \rangle) = a | \alpha \rangle - b | \beta \rangle</script>

<p>Similarly, 
<script type="math/tex">2 |\psi \rangle \langle \psi | - I</script> 
also performs a reflection in the plane about the vector 
<script type="math/tex">|\psi \rangle</script>
. The product of two reflections is a rotation!</p>

<p>Thus 
<script type="math/tex">G^k| \psi \rangle</script> 
remains in the space spanned by 
<script type="math/tex">|\alpha \rangle</script> 
and 
<script type="math/tex">|\beta \rangle</script>
. 
Let 
<script type="math/tex">\cos \big( \frac{\theta}{2} \big) = \sqrt{\frac{N- M}{N}}</script>
, so that 
<script type="math/tex">|\psi \rangle = \cos \frac{\theta}{2} |\alpha \rangle + \sin \frac{\theta}{2} |\beta\rangle</script>
. Let’s see what happens on a grover iteration:</p>

<p style="text-align:center;"><img src="/n-blog/assets/2020-07-04-Grover_files/Grover.jpg" /></p>
<p style="text-align:center;">Figure 3: Geometric representation of the Grover Iteration</p>

<p>We see from the figure that:</p>

<script type="math/tex; mode=display">G | \psi \rangle = \cos \frac{3 \theta}{2} | \alpha \rangle + \sin \frac{3 \theta}{2} | \beta \rangle</script>

<p>So the rotation is equal to <script type="math/tex">\theta</script>. It follows that after k iterations of G, we have:</p>

<script type="math/tex; mode=display">G^k | \psi \rangle = \cos \bigg( \frac{2k + 1}{2} \theta \bigg) | \alpha \rangle + \sin \bigg( \frac{2k + 1}{2} \theta \bigg) | \beta \rangle</script>

<p>Thus, in the 
<script type="math/tex">\{ | \alpha \rangle, | \beta \rangle \}</script> 
basis, we can write the Grover iteration as:</p>

<script type="math/tex; mode=display">% <![CDATA[
G = \begin{bmatrix}
    \cos \theta & - \sin \theta \\
    \sin \theta & \cos \theta
    \end{bmatrix} %]]></script>

<p>Where <script type="math/tex">\theta \in [0, \frac{\pi}{2}]</script> and <script type="math/tex">\sin \theta = \sin \bigg( \frac{\theta}{2} + \frac{\theta}{2} \bigg) = 2 \sin \frac{\theta}{2} \cos \frac{\theta}{2} \Rightarrow \sin \theta = 2 \frac{\sqrt{M(N-M)}}{N}</script>.</p>

<p>In conclusion, the grover iteration acts as a rotation towards 
<script type="math/tex">| \beta \rangle</script> 
in the space spanned by 
<script type="math/tex">\{ | \alpha \rangle, | \beta \rangle \}</script>
, so repeated applications of G are required for us to measure 
<script type="math/tex">| \beta \rangle</script> 
with high probability.</p>

<h2 id="23-performance-of-the-algorithm">2.3) Performance of the Algorithm</h2>

<p>How many times we need to repeat the Grover operator in order to rotate 
<script type="math/tex">|\psi \rangle</script> 
near 
<script type="math/tex">| \beta \rangle</script>
?</p>

<p>The initial system starts with 
<script type="math/tex">|\psi \rangle = \sqrt{\frac{N-M}{N}} | \alpha \rangle + \sqrt{\frac{M}{N}} | \beta \rangle</script>
, so rotating through <script type="math/tex">\arccos \sqrt{\frac{M}{N}}</script> radians takes the system to 
<script type="math/tex">| \beta \rangle</script>
. Let denote the closest integer to the real number <script type="math/tex">x</script> as <script type="math/tex">\mathrm{CI}(x)</script>, where we round halves down. Then repeating the grover iteration <script type="math/tex">R = \mathrm{CI}\bigg( \frac{\arccos \sqrt{\frac{M}{N}}}{\theta} \bigg)</script> times rotates 
<script type="math/tex">|\psi \rangle</script> 
within an angle <script type="math/tex">\frac{\theta}{2} \leq \frac{\pi}{4}</script> of 
<script type="math/tex">| \beta \rangle</script>
.</p>

<p>Observation of the state in the computational basis then yields a solution to the search problem with a probability at least <script type="math/tex">\frac{1}{2}</script>. For specific values of M and N it is possible to achieve higher probability of success. For example, if <script type="math/tex">% <![CDATA[
M << N %]]></script>, we have that <script type="math/tex">\sin \theta \approx \theta</script>, and thus the angular error in the final state is at most <script type="math/tex">\frac{\theta}{2} \approx \sqrt{\frac{M}{N}}</script>, giving probability of at most <script type="math/tex">\frac{M}{N}</script>.</p>

<p>The form of R is an exact expression for the query complexity of the search algorithm, but we can have a simpler expression that summarizes the essential behaviour of R. Note that <script type="math/tex">R \leq \lceil \frac{\pi}{2 \theta} \rceil</script>, because <script type="math/tex">\arccos \sqrt{\frac{M}{N} \leq \frac{\pi}{2}}</script>, so we can give an upper bound on R. Firstly we assume <script type="math/tex">M \leq \frac{N}{2}</script>, thus <script type="math/tex">\frac{\theta}{2} \geq \sin \frac{\theta}{2} = \sqrt{\frac{M}{N}}</script>. Then we have a upper bound for R:</p>

<p>\begin{equation}
    R \leq \bigg\lceil \frac{\pi}{4} \sqrt{\frac{
    N}{M}} \ \bigg\rceil
\end{equation}</p>

<p>Thus, <script type="math/tex">R = O\big( \sqrt{\frac{N}{M}} \big)</script> oracle calls must be performed in order to obtain a solution with high probability. We have a polynomial speed-up over the classical algorithm.</p>

<p>We only considered the case when <script type="math/tex">% <![CDATA[
M < \frac{N}{2} %]]></script>, what happens if this is not the case? In this case the angle <script type="math/tex">\theta</script> gets smaller and we need more interactions as M increases. But since we expect to be easy to find a solution ( because <script type="math/tex">M \geq \frac{N}{2}</script> ) we can randomly pick a solution and check if it is a solution using the oracle. This succeeds with probability at least <script type="math/tex">\frac{1}{2}</script>, and requires only one query of the oracle, but only works if we know the number of solutions in advance.</p>

<p>If we don’t know that <script type="math/tex">M \geq \frac{N}{2}</script>. We can double the number of elements in the search space by adding N extra items, none which are solutions. This is done by adding a single qubit 
<script type="math/tex">| q \rangle</script> 
to the search index, doubling the numbers of items to be searched to <script type="math/tex">2N</script>. A new augmented oracle <script type="math/tex">O'</script> can be constructed in a way that marks an item only if it is a solution to the search problem and the extra bit is set to zero; The new search problem has only M solutions out of <script type="math/tex">2N</script>, so using <script type="math/tex">R = \frac{\pi}{4} \sqrt{\frac{2N}{M}}</script> queries of <script type="math/tex">O'</script> we get a solution of high probability, since we are using the Big-O notation  we are ignoring constants that multiply the scaling and we have the same scaling <script type="math/tex">O \big( \sqrt{\frac{N}{M}} \big)</script>.</p>

<h1 id="3-example-for-n4">3) Example for N=4</h1>

<p>Here I will follow the <a href="https://qiskit.org/textbook/ch-algorithms/grover.html">Qiskit Book</a> and we will focus on the implementation for <script type="math/tex">N=4</script>, but the algorithm implementation is not hard to scale up for any <script type="math/tex">N</script>.</p>

<p>The first part of the algorithm is to build an oracle that marks the desired state, let’s consider the marked up state 
<script type="math/tex">\left| 11 \right></script>
.</p>

<p>Therefore, we need that the oracle acts as follows:</p>

<script type="math/tex; mode=display">O \left|s \right> = O \ \frac{1}{2} \ \bigg( \left| 00 \right> + \left| 01 \right> + \left| 10 \right> + \left| 11 \right> \bigg) = \frac{1}{2} \ \bigg( \left| 00 \right> + \left| 01 \right> + \left| 10 \right> - \left| 11 \right> \bigg)</script>

<p>This is the same as a controled Z gate, that means if your first qubit is 
<script type="math/tex">\left| 1 \right></script>
, then you apply an Z operator on the seccond qubit:</p>

<script type="math/tex; mode=display">% <![CDATA[
\mathrm{CZ} = \left| 0 \right> \left< 0 \right| \otimes 1 + \left| 1 \right> \left< 1 \right| \otimes Z %]]></script>

<p>This can be done by the reflection: 
<script type="math/tex">% <![CDATA[
D = 2 \left| s \right> \left< s \right| - 1 %]]></script>
.</p>

<p>It can be shown that: <script type="math/tex">D = H^{2\otimes}D'H^{2\otimes}</script>, where:</p>

<script type="math/tex; mode=display">% <![CDATA[
D' = \begin{pmatrix}
    1 &  0  & 0 & 0 \\
    0 & -1  & 0 & 0 \\
    0 &  0 & -1 & 0 \\
    0 &  0 & 0 & -1
    \end{pmatrix} %]]></script>

<p>Therefore:</p>

<script type="math/tex; mode=display">D' \left|s\right> = \frac{1}{2} \ \bigg( \left|00\right> - \left|01\right> - \left|10\right> - \left|11\right> \bigg)</script>

<p>We know that the state 
<script type="math/tex">\left| 00 \right></script> 
is the only one that changes the sign and we also know that we can change the sign of 
<script type="math/tex">\left| 11 \right></script> 
by an CZ gate. The other signs can be changed using Z gates on each qubit, because 
<script type="math/tex">Z \left| i\right> = (-1)^i \left|i \right></script>
.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
<span class="kn">import</span> <span class="nn">qiskit</span> <span class="k">as</span> <span class="n">Qsk</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
</code></pre></div></div>

<h2 id="circuit">Circuit</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Q_Reg</span> <span class="o">=</span> <span class="n">Qsk</span><span class="p">.</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">C_Reg</span> <span class="o">=</span> <span class="n">Qsk</span><span class="p">.</span><span class="n">ClassicalRegister</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Q_Circuit</span> <span class="o">=</span> <span class="n">Qsk</span><span class="p">.</span><span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">Q_Reg</span><span class="p">,</span><span class="n">C_Reg</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#Grover
</span>
<span class="n">Q_Circuit</span><span class="p">.</span><span class="n">h</span><span class="p">(</span><span class="n">Q_Reg</span><span class="p">);</span>
<span class="n">Q_Circuit</span><span class="p">.</span><span class="n">cz</span><span class="p">(</span><span class="n">Q_Reg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Q_Reg</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="n">Q_Circuit</span><span class="p">.</span><span class="n">h</span><span class="p">(</span><span class="n">Q_Reg</span><span class="p">);</span>
<span class="n">Q_Circuit</span><span class="p">.</span><span class="n">z</span><span class="p">(</span><span class="n">Q_Reg</span><span class="p">);</span>
<span class="n">Q_Circuit</span><span class="p">.</span><span class="n">cz</span><span class="p">(</span><span class="n">Q_Reg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Q_Reg</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="n">Q_Circuit</span><span class="p">.</span><span class="n">h</span><span class="p">(</span><span class="n">Q_Reg</span><span class="p">);</span>

<span class="c1">#Measurement
</span>
<span class="n">Q_Circuit</span><span class="p">.</span><span class="n">barrier</span><span class="p">(</span><span class="n">Q_Reg</span><span class="p">);</span>
<span class="n">Q_Circuit</span><span class="p">.</span><span class="n">measure</span><span class="p">(</span><span class="n">Q_Reg</span><span class="p">,</span><span class="n">C_Reg</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Q_Circuit</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s">'mpl'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/n-blog/assets/2020-07-04-Grover_files/2020-07-04-Grover_16_0.svg" /></p>

<h2 id="simulation">Simulation</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">backend_sim</span> <span class="o">=</span> <span class="n">Qsk</span><span class="p">.</span><span class="n">Aer</span><span class="p">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s">'qasm_simulator'</span><span class="p">)</span>
<span class="n">job_sim</span> <span class="o">=</span> <span class="n">Qsk</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="n">Q_Circuit</span><span class="p">,</span> <span class="n">backend_sim</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>
<span class="n">result_sim</span> <span class="o">=</span> <span class="n">job_sim</span><span class="p">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">result_sim</span><span class="p">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">Q_Circuit</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/n-blog/assets/2020-07-04-Grover_files/2020-07-04-Grover_19_0.svg" /></p>

<h2 id="running-on-ibmq">Running on IBMQ</h2>

<p>We will choose the least busy backend with at least two qubits.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">IBMQ</span>
<span class="kn">from</span> <span class="nn">qiskit.providers.ibmq</span> <span class="kn">import</span> <span class="n">least_busy</span>

<span class="n">provider</span> <span class="o">=</span> <span class="n">IBMQ</span><span class="p">.</span><span class="n">load_account</span><span class="p">();</span>
<span class="n">num_qubits</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">backend</span> <span class="o">=</span> <span class="n">least_busy</span><span class="p">(</span><span class="n">provider</span><span class="p">.</span><span class="n">backends</span><span class="p">(</span><span class="n">filters</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">.</span><span class="n">configuration</span><span class="p">().</span><span class="n">n_qubits</span> <span class="o">&gt;=</span> <span class="n">num_qubits</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">x</span><span class="p">.</span><span class="n">configuration</span><span class="p">().</span><span class="n">simulator</span> <span class="ow">and</span> <span class="n">x</span><span class="p">.</span><span class="n">status</span><span class="p">().</span><span class="n">operational</span><span class="o">==</span><span class="bp">True</span><span class="p">))</span>
<span class="n">backend</span>

</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;IBMQBackend('ibmq_ourense') from IBMQ(hub='ibm-q', group='open', project='main')&gt;
</code></pre></div></div>

<p>Submiting the job for the IBM Q platform</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">qiskit.tools.monitor</span> <span class="kn">import</span> <span class="n">job_monitor</span>

<span class="n">job_exp</span> <span class="o">=</span> <span class="n">Qsk</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="n">Q_Circuit</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">)</span>
<span class="n">job_monitor</span><span class="p">(</span><span class="n">job_exp</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Job Status: job has successfully run
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">result_exp</span> <span class="o">=</span> <span class="n">job_exp</span><span class="p">.</span><span class="n">result</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span>
<span class="n">counts_exp</span> <span class="o">=</span> <span class="n">result_exp</span><span class="p">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">Q_Circuit</span><span class="p">)</span>
<span class="n">plot_histogram</span><span class="p">([</span><span class="n">counts_exp</span><span class="p">,</span><span class="n">counts</span><span class="p">],</span> <span class="n">legend</span><span class="o">=</span><span class="p">[</span><span class="s">'Device'</span><span class="p">,</span> <span class="s">'Simulator'</span><span class="p">])</span>
</code></pre></div></div>

<p><img src="/n-blog/assets/2020-07-04-Grover_files/2020-07-04-Grover_25_0.svg" /></p>

<h1 id="references">References</h1>

<p>1 -  Michael A. Nielsen and Isaac L. Chuang.Quantum Computation and Quantum Information:  10th Anniversary Edition.Cambridge University Press, 2010</p>

<p>2 -   Giuliano Benenti, Giulio Casati, and Giuliano Strini.Principles  of  Quantum  Computation  and  Information.  World Scientific, 2004.</p>

<p>3 - <a href="https://qiskit.org/textbook/">Qiskit Book</a></p>

<hr />

<h3>Version Information</h3>
<table><tr><th>Qiskit Software</th><th>Version</th></tr><tr><td>Qiskit</td><td>0.19.1</td></tr><tr><td>Terra</td><td>0.14.1</td></tr><tr><td>Aer</td><td>0.5.1</td></tr><tr><td>Ignis</td><td>0.3.0</td></tr><tr><td>Aqua</td><td>0.7.0</td></tr><tr><td>IBM Q Provider</td><td>0.7.0</td></tr><tr><th>System information</th></tr><tr><td>Python</td><td>3.7.3 | packaged by conda-forge | (default, Jul  1 2019, 21:52:21) 
[GCC 7.3.0]</td></tr><tr><td>OS</td><td>Linux</td></tr><tr><td>CPUs</td><td>2</td></tr><tr><td>Memory (Gb)</td><td>7.664028167724609</td></tr><tr><td colspan="2">Sat Jul 04 17:45:24 2020 -03</td></tr></table>


  </div>

</article>

      </div>
    </div>    

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">N-Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>N-Blog</li>
          <li><a href="mailto:nahumsa@cbpf.br">nahumsa@cbpf.br</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/nahumsa"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">nahumsa</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/sa_nahum"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">sa_nahum</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Here I will share thoughts and ideas about Machine Learning  and Quantum Computing.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
