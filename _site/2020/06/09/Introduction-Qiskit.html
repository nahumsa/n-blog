<!DOCTYPE html>
<html>

  <!-- Mathjax Support -->
<!-- <script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script> -->

<!-- For Latex -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" href="assets/images/favicon.ico" type="image/png" />
  <title>Introduction to IBM Qiskit</title>
  <meta name="description" content="First steps into Quantum Computing">
  <link rel="stylesheet" href="/n-blog/css/main.css">
  <link rel="canonical" href="http://localhost:4000/n-blog/2020/06/09/Introduction-Qiskit.html">
  <link rel="alternate" type="application/rss+xml" title="N-Blog" href="http://localhost:4000/n-blog/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/n-blog/">N-Blog</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/n-blog/about/">About</a>
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Introduction to IBM Qiskit</h1>
    <p class="post-meta"><time datetime="2020-06-09T16:00:00-03:00" itemprop="datePublished">Jun 9, 2020</time></p>
    
    <span>
      
        
        <a class="post-tag" href="/n-blog/tag/Quantum-Computing"><nobr>Quantum-Computing</nobr>&nbsp;</a>
      
        
        <a class="post-tag" href="/n-blog/tag/Qiskit"><nobr>Qiskit</nobr>&nbsp;</a>
      
        
        <a class="post-tag" href="/n-blog/tag/Tutorial"><nobr>Tutorial</nobr>&nbsp;</a>
      
    </span>
  </header>
  
  <div class="post-content" itemprop="articleBody">
    <h1 id="first-steps-into-quantum-computing">First steps into Quantum Computing</h1>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
<span class="kn">import</span> <span class="nn">qiskit</span> <span class="k">as</span> <span class="n">qsk</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
</code></pre></div></div>

<h1 id="1-introduction">1) Introduction</h1>

<p>In this notebook I will introduce some important functions to use IBM qiskit, this will be done by an example of constructing an entangled state.</p>

<h1 id="2-building-a-entangled-stated-from-scratch">2) Building a entangled stated from scratch</h1>

<p>We want to build a Bell State from a state</p>

<script type="math/tex; mode=display">\left| 00 \right></script>

<p>the final state is:</p>

<script type="math/tex; mode=display">\left| \psi \right> = \frac{\left| 00 \right> - \left| 11 \right>}{\sqrt 2}</script>

<p>There are many gates, for reference see the <a href="https://qiskit.org/textbook/ch-states/single-qubit-gates.html">qiskit book</a>. The gates that we will use are:</p>

<ul>
  <li>Pauli X: This is an one qubit gate that is represented on the computational basis by:</li>
</ul>

<script type="math/tex; mode=display">% <![CDATA[
X = \frac{1}{\sqrt2}
 \begin{pmatrix} 
    0 & 1\\
    1 & 0 \\
 \end{pmatrix} %]]></script>

<ul>
  <li>Hadamard: This is an one qubit gate that is represented on the computational basis by:</li>
</ul>

<script type="math/tex; mode=display">% <![CDATA[
H = \frac{1}{\sqrt2}
    \begin{pmatrix} 
    1 & 1\\
    1 & -1 \\
    \end{pmatrix} %]]></script>

<ul>
  <li><script type="math/tex">C_x</script>(Controlled X): This is a two qubit gate that changes the second qubit if the first qubit is on the state</li>
</ul>

<script type="math/tex; mode=display">\left| 1 \right></script>

<p>On the computational basis is represented by:</p>

<script type="math/tex; mode=display">% <![CDATA[
C_x  = 
    \begin{pmatrix} 
    1 & 0 & 0 & 0 \\
    0 & 1 & 0 & 0 \\
    0 & 0 & 0 & 1 \\
    0 & 0 & 1 & 0 \\
    \end{pmatrix} %]]></script>

<h2 id="21-initializing-quantum-circuits">2.1) Initializing quantum circuits</h2>

<p>In qiskit there are many ways to initialize a quantum circuit, the easiest one is using the <code class="highlighter-rouge">QuantumCircuit</code> module on qiskit, this takes two arguments <code class="highlighter-rouge">qregisters</code> that can be a <code class="highlighter-rouge">QuantumRegister</code> or an int that designates how many quantum wires you want on your circuit, the other argument is <code class="highlighter-rouge">cregisters</code> that can be a <code class="highlighter-rouge">ClassicalRegister</code> or an int that designates how many classical wires you want on your circuit. An optional argument is the <code class="highlighter-rouge">Name</code> that will put a name on your circuit.</p>

<p>I usually recommend starting using <code class="highlighter-rouge">QuantumRegister</code> and <code class="highlighter-rouge">ClassicalRegister</code> to build circuits, because this will modularize your code moving forward.</p>

<p>In order to see what you are doing, you can use the method <code class="highlighter-rouge">draw</code> inside <code class="highlighter-rouge">QuantumCircuit</code>, to make an image you use the ‘mpl’ argument inside the method.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">qreg</span> <span class="o">=</span> <span class="n">qsk</span><span class="p">.</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">'q'</span><span class="p">)</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">qsk</span><span class="p">.</span><span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">qreg</span><span class="p">)</span>
<span class="n">circ</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="s">'mpl'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/n-blog/assets/09-06-2020-Introduction-Qiskit_files/09-06-2020-Introduction-Qiskit_5_0.svg" /></p>

<h2 id="22-adding-gates">2.2) Adding Gates</h2>

<p>The main gates are methods inside you <code class="highlighter-rouge">QuantumCircuit</code>, thus if you want to add them you should only use .nameofthegate , in the introduction section there is a link to all gates on qiskit.</p>

<p>Since this is the first example, I shall use linear algebra to show what is happening when you use those gates to construct our entangled state.</p>

<p>All circuits on qiskit starts on the state</p>

<script type="math/tex; mode=display">\left| 0 \right> = \begin{pmatrix} 1 \\ 0 \end{pmatrix}</script>

<p>our first opperation is to transform the</p>

<script type="math/tex; mode=display">\left| 0 \right></script>

<p>state into</p>

<script type="math/tex; mode=display">\left| 1 \right></script>

<p>state, this is done by the Pauli X gate:</p>

<script type="math/tex; mode=display">% <![CDATA[
X \left| 0 \right> = \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix} \cdot \begin{pmatrix} 1 \\ 0 \end{pmatrix} = \begin{pmatrix} 0 \\ 1 \end{pmatrix} = \left| 1 \right> %]]></script>

<p>Thus we apply the X gate on the first register, this is done by assigning the gate to the position <code class="highlighter-rouge">0</code> of the QuantumRegister.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">circ</span><span class="p">.</span><span class="n">x</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">#Add x on 0
</span><span class="n">circ</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="s">'mpl'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/n-blog/assets/09-06-2020-Introduction-Qiskit_files/09-06-2020-Introduction-Qiskit_7_0.svg" /></p>

<p>Now we apply the Haddamard gate on the first register, since the register is already on</p>

<script type="math/tex; mode=display">\left| 1 \right></script>

<p>we have:</p>

<script type="math/tex; mode=display">% <![CDATA[
H \left| 1 \right> = \begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix} \cdot \begin{pmatrix} 0 \\ 1 \end{pmatrix} = \begin{pmatrix} 1 \\ -1 \end{pmatrix} = \frac{1}{\sqrt{2}} \bigg( \left| 0 \right> - \left| 1 \right> \bigg) %]]></script>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">circ</span><span class="p">.</span><span class="n">h</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">#Add x on 0
</span><span class="n">circ</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="s">'mpl'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/n-blog/assets/09-06-2020-Introduction-Qiskit_files/09-06-2020-Introduction-Qiskit_9_0.svg" /></p>

<p>In order to have an entangled state we shall use a gate that works on two qubits, this is done by the CNOT gate (also known as C-X), this will entangle the first and second qubit. It is important to note that now we have <script type="math/tex">2^2 = 4</script> states (because we are working with two qubits). The CNOT works in this manner:</p>

<script type="math/tex; mode=display">C_x \left| a \right>\left| b \right> = \left| a \right>\left| a \oplus b \right></script>

<p>where <script type="math/tex">\oplus</script> means bitwise sum.</p>

<script type="math/tex; mode=display">C_x \frac{1}{\sqrt{2}} \bigg( \left| 0 \right> - \left| 1 \right> \bigg)\left| 0 \right> = \frac{1}{\sqrt{2}} \bigg( \left| 0 \right>\left| 0 \oplus 0 \right> - \left| 1 \right>\left| 1 \oplus 0 \right> \bigg) = \frac{1}{\sqrt{2}} \bigg( \left| 00 \right> - \left| 11 \right> \bigg)</script>

<p>That is exactly what we wanted.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">circ</span><span class="p">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">#Add CNOT on 0 and 1
</span><span class="n">circ</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s">'mpl'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/n-blog/assets/09-06-2020-Introduction-Qiskit_files/09-06-2020-Introduction-Qiskit_11_0.svg" /></p>

<h2 id="23-running-a-simulation-of-our-circuit-locally">2.3) Running a simulation of our circuit locally</h2>

<p>There are several ways to run your circuits, you can run them locally or remotely on a real Quantum Computer. Now I will explain how to run it locall.</p>

<p>For a local simulation, we will use <code class="highlighter-rouge">qiskit.Aer</code> which is a high performance simulator that uses C++ simulator backends. We choose backend to run our circuit depending on what we need, here are some examples of backends:</p>

<ul>
  <li>
    <p>qasm_simulator: Runs the circuit just as the actual circuit on a quantum computer is run, therefore you need to measure the qubits at the end.</p>
  </li>
  <li>
    <p>statevector_simulator: Outputs the state on an ideal quantum circuit.</p>
  </li>
  <li>
    <p>unitary_simulator: Outputs the unitary operator of the given circuit.</p>
  </li>
  <li>
    <p>pulse_simulator: Simulates a pulse schedule for the circuit.</p>
  </li>
</ul>

<h3 id="231-statevector_simulator">2.3.1) statevector_simulator</h3>

<p>In this example we chose to run on the statevector_simulator in order to see if our circuit outputs exactly our desired state. Firstly, we chose the backend and then submit the job for the chosen backend using <code class="highlighter-rouge">qiskit.execute</code>. Lastly, we retrieve the job by calling <code class="highlighter-rouge">job.result()</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">backend</span> <span class="o">=</span> <span class="n">qsk</span><span class="p">.</span><span class="n">Aer</span><span class="p">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s">'statevector_simulator'</span><span class="p">)</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">qsk</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">job</span><span class="p">.</span><span class="n">result</span><span class="p">()</span>
</code></pre></div></div>

<p>Let’s print our result:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">outputstate</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">get_statevector</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">outputstate</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ 0.707-0.j  0.   +0.j  0.   +0.j -0.707+0.j]
</code></pre></div></div>

<p>We can also visualize our result by plotting the <a href="https://en.wikipedia.org/wiki/Density_matrix">density matrix</a> of our state, this is done by taking the outer product of our state.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_state_city</span>
<span class="n">plot_state_city</span><span class="p">(</span><span class="n">outputstate</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/n-blog/assets/09-06-2020-Introduction-Qiskit_files/09-06-2020-Introduction-Qiskit_18_0.svg" /></p>

<h3 id="232-qasm_simullator">2.3.2) qasm_simullator</h3>

<p>The previous simulation is a theoretical realization of our circuit, but when you are working with a real quantum computer you have to measure your qubits in order to get your results. This will cause the qubits to colapse to bits and we can acces them.</p>

<p>So we need to add the measurments on our circuits, this is done by adding a <code class="highlighter-rouge">ClassicalRegister</code> to our circuit.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">creg</span> <span class="o">=</span> <span class="n">qsk</span><span class="p">.</span><span class="n">ClassicalRegister</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">'c'</span><span class="p">)</span>
<span class="n">circ</span><span class="p">.</span><span class="n">add_register</span><span class="p">(</span><span class="n">creg</span><span class="p">)</span>
<span class="n">circ</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="s">'mpl'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/n-blog/assets/09-06-2020-Introduction-Qiskit_files/09-06-2020-Introduction-Qiskit_20_0.svg" /></p>

<p>We map the measurment from our quantum qubits to our classical bits.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">circ</span><span class="p">.</span><span class="n">measure</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span><span class="n">creg</span><span class="p">)</span>
<span class="n">circ</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="s">'mpl'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/n-blog/assets/09-06-2020-Introduction-Qiskit_files/09-06-2020-Introduction-Qiskit_22_0.svg" /></p>

<p>Now we can simulate a real quantum computer using qasm_simulator, we need to define how many times our circuit will run, this is called “shots”, here we chose 1024 times.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">backend_sim</span> <span class="o">=</span> <span class="n">qsk</span><span class="p">.</span><span class="n">Aer</span><span class="p">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s">'qasm_simulator'</span><span class="p">)</span>
<span class="n">job_sim</span> <span class="o">=</span> <span class="n">qsk</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">backend_sim</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>
<span class="n">result_sim</span> <span class="o">=</span> <span class="n">job_sim</span><span class="p">.</span><span class="n">result</span><span class="p">()</span>
</code></pre></div></div>

<p>To acces the count of our state, we use the .get_counts(circ) that will give us a dictionary with the count of each state.</p>

<p>The best way to visualize this result is using a histogram that will output the probability associated with each state</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">counts</span> <span class="o">=</span> <span class="n">result_sim</span><span class="p">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{'00': 532, '11': 492}
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/n-blog/assets/09-06-2020-Introduction-Qiskit_files/09-06-2020-Introduction-Qiskit_27_0.svg" /></p>

<p>Therefore, we have approximately 50% shots on each state. This is exactly what we expected for the bell state.</p>

<p>Note that by this method we cannot know the phase associated with each state, therefore we don’t know if our state is any specific bell state, we only know that there are only ‘00’ and ‘11’ qubits on our state.</p>

<p>To get the exact state, we need to do <a href="https://en.wikipedia.org/wiki/Quantum_tomography">Quantum State Tomography</a>, which I will talk about it in the future.</p>

<h2 id="24-runing-the-circuit-on-a-real-quantum-computer">2.4) Runing the circuit on a real Quantum Computer</h2>

<p>In order to acces the IBM Q, you will need to <a href="https://quantum-computing.ibm.com/">register</a> and copy the Token from you profile. Here the token is on a <code class="highlighter-rouge">.txt</code> file in order to the token remain private on the code.</p>

<p>You only need to register your account on your computer once using <code class="highlighter-rouge">save_account</code>, after this you can get acces your account using <code class="highlighter-rouge">load_account</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">IBMQ</span>
<span class="n">token</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s">"Token.txt"</span><span class="p">,</span> <span class="n">unpack</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="n">IBMQ</span><span class="p">.</span><span class="n">save_account</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">provider</span> <span class="o">=</span> <span class="n">IBMQ</span><span class="p">.</span><span class="n">load_account</span><span class="p">();</span>
</code></pre></div></div>

<p>There are several devices that we can access by registering to IBMQ, let’s see which ones are available to us.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">backend_list</span> <span class="o">=</span> <span class="n">provider</span><span class="p">.</span><span class="n">backends</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">backend_list</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">f'</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s"> </span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ibmq_qasm_simulator 

ibmqx2 

ibmq_16_melbourne 

ibmq_vigo 

ibmq_ourense 

ibmq_london 

ibmq_burlington 

ibmq_essex 

ibmq_armonk 

ibmq_rome 
</code></pre></div></div>

<p>Let’s choose the least busy device that has at least 2 qubits.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">qiskit.providers.ibmq</span> <span class="kn">import</span> <span class="n">least_busy</span>

<span class="n">num_qubits</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">backend</span> <span class="o">=</span> <span class="n">least_busy</span><span class="p">(</span><span class="n">provider</span><span class="p">.</span><span class="n">backends</span><span class="p">(</span><span class="n">filters</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">.</span><span class="n">configuration</span><span class="p">().</span><span class="n">n_qubits</span> <span class="o">&gt;=</span> <span class="n">num_qubits</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">x</span><span class="p">.</span><span class="n">configuration</span><span class="p">().</span><span class="n">simulator</span> <span class="ow">and</span> <span class="n">x</span><span class="p">.</span><span class="n">status</span><span class="p">().</span><span class="n">operational</span><span class="o">==</span><span class="bp">True</span><span class="p">))</span>
<span class="n">backend</span>

</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;IBMQBackend('ibmqx2') from IBMQ(hub='ibm-q', group='open', project='main')&gt;
</code></pre></div></div>

<p>Now we submit our job for the IBM Q platform, and monitor it by using the function <code class="highlighter-rouge">job_monitor</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">qiskit.tools.monitor</span> <span class="kn">import</span> <span class="n">job_monitor</span>

<span class="n">job_exp</span> <span class="o">=</span> <span class="n">qsk</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">)</span>
<span class="n">job_monitor</span><span class="p">(</span><span class="n">job_exp</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Job Status: job has successfully run
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">result_exp</span> <span class="o">=</span> <span class="n">job_exp</span><span class="p">.</span><span class="n">result</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span>
<span class="n">counts_exp</span> <span class="o">=</span> <span class="n">result_exp</span><span class="p">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
<span class="n">plot_histogram</span><span class="p">([</span><span class="n">counts_exp</span><span class="p">,</span><span class="n">counts</span><span class="p">],</span> <span class="n">legend</span><span class="o">=</span><span class="p">[</span><span class="s">'Device'</span><span class="p">,</span> <span class="s">'Simulator'</span><span class="p">])</span>
</code></pre></div></div>

<p><img src="/n-blog/assets/09-06-2020-Introduction-Qiskit_files/09-06-2020-Introduction-Qiskit_39_0.svg" /></p>

<p>We can see that on our simulator everything is perfect, but when running on a real device there are several errors that occurs when running your circuit. I will explain some ways to correct those errors using linear algebra on other notebooks.</p>

<h2 id="24-retriving-older-jobs">2.4) Retriving older jobs</h2>

<p>If you want to retrieve older jobs after closing your code you need your job_id</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">job_id</span> <span class="o">=</span> <span class="n">job_exp</span><span class="p">.</span><span class="n">job_id</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="s">'JOB ID: {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">job_id</span><span class="p">))</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>JOB ID: 5ee007e341d47c001309221f
</code></pre></div></div>

<p>To acces your old job, you need to be in the same backend</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">retrieved_job</span> <span class="o">=</span> <span class="n">backend</span><span class="p">.</span><span class="n">retrieve_job</span><span class="p">(</span><span class="n">job_id</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">retrieved_job</span><span class="p">.</span><span class="n">result</span><span class="p">().</span><span class="n">get_counts</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{'01': 17, '10': 9, '00': 533, '11': 465}
</code></pre></div></div>

<hr />

<p>The code for this post is on <a href="https://github.com/nahumsa/Introduction-to-IBM_Qiskit/blob/master/Notebooks/%20Initial_Tutorial.ipynb">github</a></p>

<hr />

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">qiskit.tools.jupyter</span> <span class="kn">import</span> <span class="o">*</span>
<span class="o">%</span><span class="n">qiskit_version_table</span>
</code></pre></div></div>

<h3>Version Information</h3>
<table><tr><th>Qiskit Software</th><th>Version</th></tr><tr><td>Qiskit</td><td>0.19.1</td></tr><tr><td>Terra</td><td>0.14.1</td></tr><tr><td>Aer</td><td>0.5.1</td></tr><tr><td>Ignis</td><td>0.3.0</td></tr><tr><td>Aqua</td><td>0.7.0</td></tr><tr><td>IBM Q Provider</td><td>0.7.0</td></tr><tr><th>System information</th></tr><tr><td>Python</td><td>3.7.3 | packaged by conda-forge | (default, Jul  1 2019, 21:52:21) 
[GCC 7.3.0]</td></tr><tr><td>OS</td><td>Linux</td></tr><tr><td>CPUs</td><td>2</td></tr><tr><td>Memory (Gb)</td><td>7.664028167724609</td></tr><tr><td colspan="2">Tue Jun 09 19:08:19 2020 -03</td></tr></table>


  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">N-Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>N-Blog</li>
          <li><a href="mailto:nahumsa@cbpf.br">nahumsa@cbpf.br</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/nahumsa"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">nahumsa</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/sa_nahum"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">sa_nahum</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Here I will share thoughts and ideas about Machine Learning  and Quantum Computing.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
