<!doctype html><html prefix="og: http://ogp.me/ns#"><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Deutsch Algorithm</title><meta name=description content="1) Introduction The Deutsch algorithm is idealized to be easy for a quantum computer with a oracle and hard for a classical deterministic computer. Therefore, it is not directly applicable to a defined problem and works more like a proof that Quantum Computers could be faster than a Classical Computer.
This algorithm is later generalized for a function with more inputs, which is called the Deutsch-Josza Algorithm, which proves an exponential speedup relative to a classical deterministic computer, it is important to note that this doesn&rsquo;t prove an exponential speedup comparing to a Probabilistic Classical Computer."><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=generator content="Hugo 0.82.0"><meta name=robots content="index,follow"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="Deutsch Algorithm"><meta property="og:description" content="1) Introduction The Deutsch algorithm is idealized to be easy for a quantum computer with a oracle and hard for a classical deterministic computer. Therefore, it is not directly applicable to a defined problem and works more like a proof that Quantum Computers could be faster than a Classical Computer.
This algorithm is later generalized for a function with more inputs, which is called the Deutsch-Josza Algorithm, which proves an exponential speedup relative to a classical deterministic computer, it is important to note that this doesn&rsquo;t prove an exponential speedup comparing to a Probabilistic Classical Computer."><meta property="og:type" content="article"><meta property="og:url" content="https://nahumsa.github.io/n-blog/2020-06-18-deutsch/"><link rel=stylesheet href=https://nahumsa.github.io/n-blog/dist/site.css><link rel=stylesheet href=https://nahumsa.github.io/n-blog/dist/syntax.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,400,600,700,300&subset=latin,cyrillic-ext,latin-ext,cyrillic"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous><link rel="shortcut icon" type=image/jpg href=https://nahumsa.github.io/n-blog/favicon.ico><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}},window.addEventListener('load',a=>{document.querySelectorAll("mjx-container").forEach(function(a){a.parentElement.classList+='has-jax'})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-170504520-1','auto'),ga('send','pageview'))</script><div id=wrapper><header class=site-header><div class=container><div class=site-title-wrapper><h1 class=site-title><a href=https://nahumsa.github.io/n-blog/>n-blog</a></h1><a class="button-square button-social hint--top" data-hint=Twitter aria-label=Twitter href=https://twitter.com/sa_nahum rel=me><i class="fa fa-twitter" aria-hidden=true></i></a>
<a class="button-square button-social hint--top" data-hint=Github aria-label=Github href=https://github.com/nahumsa rel=me><i class="fa fa-github-alt" aria-hidden=true></i></a>
<a class="button-square button-social hint--top" data-hint=Email aria-label="Send an Email" href=mailto:nahumsa@cbpf.br><i class="fa fa-envelope" aria-hidden=true></i></a></div><ul class=site-nav></ul></div></header><div id=container><div class=container><article class=post-container itemscope itemtype=http://schema.org/BlogPosting><header class=post-header><h1 class=post-title itemprop="name headline">Deutsch Algorithm</h1><p class="post-date post-line"><span>Published <time datetime=2020-06-18 itemprop=datePublished>Thu, Jun 18, 2020</time></span>
<span>by</span>
<span itemscope itemprop=author itemtype=https://schema.org/Person><span itemprop=name><a href=# itemprop=url rel=author>Nahum SÃ¡</a></span></span></p></header><div class="post-content clearfix" itemprop=articleBody><h1 id=1-introduction>1) Introduction</h1><p>The Deutsch algorithm is idealized to be easy for a quantum computer with a oracle and hard for a classical deterministic computer. Therefore, it is not directly applicable to a defined problem and works more like a proof that Quantum Computers could be faster than a Classical Computer.</p><p>This algorithm is later generalized for a function with more inputs, which is called the Deutsch-Josza Algorithm, which proves an exponential speedup relative to a classical deterministic computer, it is important to note that this doesn&rsquo;t prove an exponential speedup comparing to a Probabilistic Classical Computer.</p><h1 id=2-stating-the-problem>2) Stating the problem</h1><p>Consider an oracle evaluating a 1 bit boolean function $f: { 0,1} \rightarrow { 0,1}$ we want to know if the function is constant ( $f(0) = 0$ and $f(1) = 1$) or balanced ( $f(0) = 1$ and $f(1) = 0$).</p><p>For a classical deterministic computer it is needed two queries, therefore you need to test 2 diferent bits and see the outputs, for instance if $f(0) = 0$ and $f(1) = 1$ you know that the function is constant.</p><p>For a quantum computer this can be done with only one query. This is done with the Deutsch algorithm, the idea is to check if it is balanced, if it is not balanced it is constant.</p><h1 id=3-algorithm>3) Algorithm</h1><p>The Deutsch&rsquo;s Algorithm is the following, we will consider the quantum circuit into two quantum registers, the work register(W) and the ancilla (A):</p><ul><li><ol start=0><li>Start with the state $\left| \psi_1 \right> = \left| 1 \right>_A \left| 0 \right>_W$</li></ol></li><li><ol><li>Apply a Hadamard on both qubits, the state will be:</li></ol></li></ul><p>$$
\left| \psi_2 \right> =\frac{1}{2} \left( \left| 0 \right>_A - \left| 1 \right>_A \right) \otimes \left( \left| 0 \right>_W + \left| 1 \right>_W \right)
$$</p><ul><li><ol start=2><li>Apply a Unitary operator, an oracle, such that:</li></ol></li></ul><p>$$
U_f \frac{1}{\sqrt 2} \left( \left| 0 \right>_A - \left| 1 \right>_A \right)\left| x \right>_W = (-1)^{f(x)} \frac{1}{\sqrt 2} \left( \left| 0 \right>_A - \left| 1 \right>_A \right)\left| x \right>_W
$$</p><p>The phase factor is &ldquo;kicked back&rdquo; on the front of the state, this will be useful to evaluate $f(x)$ with only one query. The state after $U_f$ is:</p><p>$$
\left| \psi_3 \right> = \frac{1}{2} \left( \left| 0 \right>_A - \left| 1 \right>_A \right) \otimes \left( (-1)^{f(0)}\left| 0 \right>_W + (-1)^{f(1)}\left| 1 \right>_W \right)
$$</p><ul><li><ol start=3><li>Apply a Hadamard on the second qubit:</li></ol></li></ul><p>$$
\left| \psi_3 \right> =\frac{1}{2} \left( \left| 0 \right>_A - \left| 1 \right>_A \right) \otimes \left[ \left((-1)^{f(0)} + (-1)^{f(1)}\right) \left| 0 \right>_W + \left((-1)^{f(0)} - (-1)^{f(1)}\right)\left| 1 \right>_W \right]
$$</p><p>Now we have two cases:</p><ul><li>If $f(0) = f(1)$ we will measure:
$$
\left| 0 \right>_W = \left| f(0) \oplus f(1) \right>_W
$$</li><li>If $f(0) \neq f(1)$ we will measure:
$$
\left| 1 \right>_W = \left| f(0) \oplus f(1) \right>_W
$$</li></ul><p>In this implementation the oracle ($U_f$) is a C-NOT gate, this will measure if the function is balanced.</p><h1 id=4-implementation-on-qiskit>4) Implementation on Qiskit</h1><p>We shall now implement this algorithm on Qiskit and run on a real Quantum Computer from IBMQ.
For this it is needed to define the oracle $U_f$ exactly.</p><h2 id=41-constructing-the-quantum-circuit>4.1) Constructing the Quantum Circuit</h2><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#555>%</span>matplotlib inline
<span style=color:#069;font-weight:700>import</span> <span style=color:#0cf;font-weight:700>qiskit</span> <span style=color:#069;font-weight:700>as</span> <span style=color:#0cf;font-weight:700>qsk</span>
<span style=color:#069;font-weight:700>import</span> <span style=color:#0cf;font-weight:700>numpy</span> <span style=color:#069;font-weight:700>as</span> <span style=color:#0cf;font-weight:700>np</span>
<span style=color:#069;font-weight:700>import</span> <span style=color:#0cf;font-weight:700>matplotlib.pyplot</span> <span style=color:#069;font-weight:700>as</span> <span style=color:#0cf;font-weight:700>plt</span>
</code></pre></div><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>qreg_w <span style=color:#555>=</span> qsk<span style=color:#555>.</span>QuantumRegister(<span style=color:#f60>1</span>, name<span style=color:#555>=</span><span style=color:#c30>&#39;w&#39;</span>)
qreg_a <span style=color:#555>=</span> qsk<span style=color:#555>.</span>QuantumRegister(<span style=color:#f60>1</span>, name<span style=color:#555>=</span><span style=color:#c30>&#39;a&#39;</span>)
qc <span style=color:#555>=</span> qsk<span style=color:#555>.</span>QuantumCircuit(qreg_w)
qc<span style=color:#555>.</span>add_register(qreg_a)
</code></pre></div><p>On Qiskit, all circuits are initialized on the state 00:</p><p>$$
\left| \psi_0 \right> = \left| 00 \right>
$$</p><p>Then we apply the X gate on the first register, in order to state be:
$$
\left| \psi_1 \right> = \left| 10 \right>
$$</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>qc<span style=color:#555>.</span>x(qreg_a);
</code></pre></div><p>Since the Haddamard gate is given by the following matrix on the computational basis:</p><p>$$
H = \frac{1}{\sqrt2}
\begin{pmatrix}
1 & 1 \\<br>1 & -1 \\<br>\end{pmatrix}
$$</p><p>Now the state is
$$
\left| \psi_2 \right> = \frac{1}{2} \left( \left| 0 \right> - \left| 1 \right> \right) \otimes \left( \left| 0 \right> + \left| 1 \right> \right)
$$</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>qc<span style=color:#555>.</span>h(qreg_w);
qc<span style=color:#555>.</span>h(qreg_a);
</code></pre></div><p>Applying the CNOT, we have:</p><p>$$
| \psi_3 \rangle = \frac{1}{2} \left[ \left| 0 \right> \otimes \left( \left| 0 \oplus 0 \right> + \left| 1 \oplus 0 \right> \right) - \left| 1 \right> \otimes \left( \left| 0 \oplus 1 \right> + \left| 1 \oplus 1 \right> \right)
\right]
$$</p><p>$$
| \psi_3 \rangle = \frac{1}{2} \left[ | 0 \rangle \otimes \left( \left| 0 \right> + \left| 1 \right> \right) - \left| 1 \right> \otimes \left( \left| 1 \right> + \left| 0 \right> \right) \right]
$$</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>qc<span style=color:#555>.</span>cx(qreg_w,qreg_a);
</code></pre></div><p>After the Hadamard on the work qubit, we have that:</p><p>$$
\left| \psi_4 \right> = \frac{1}{2} \left[ \left( \left| 0 \right> + \left| 1 \right> \right) \otimes \left( \left| 0 \right> + \left| 1 \right> \right) - \left( \left| 0 \right> - \left| 1 \right> \right) \otimes \left( \left| 1 \right> + \left| 0 \right> \right)
\right]
$$</p><p>$$
\left| \psi_4 \right> = \frac{1}{\sqrt2}
\left(
\left| 0 \right> - \left| 1 \right>
\right) \otimes
\left| 1 \right>
$$</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>qc<span style=color:#555>.</span>h(qreg_w);
</code></pre></div><h2 id=42-measuring-the-circuit>4.2) Measuring the circuit</h2><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>creg <span style=color:#555>=</span> qsk<span style=color:#555>.</span>ClassicalRegister(<span style=color:#f60>1</span>, name<span style=color:#555>=</span><span style=color:#c30>&#39;c&#39;</span>)
qc<span style=color:#555>.</span>add_register(creg)
qc<span style=color:#555>.</span>measure(qreg_w,creg)
qc<span style=color:#555>.</span>draw(output<span style=color:#555>=</span><span style=color:#c30>&#39;mpl&#39;</span>)
</code></pre></div><p><img src=/n-blog/figures/2020-06-18-Deutsch_files/2020-06-18-Deutsch_18_0.svg alt=Circuit></p><h2 id=43-running-experiments>4.3) Running Experiments</h2><h3 id=431-using-qasm_simulator>4.3.1) Using qasm_simulator</h3><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>backend_sim <span style=color:#555>=</span> qsk<span style=color:#555>.</span>Aer<span style=color:#555>.</span>get_backend(<span style=color:#c30>&#39;qasm_simulator&#39;</span>)
job_sim <span style=color:#555>=</span> qsk<span style=color:#555>.</span>execute(qc, backend_sim, shots<span style=color:#555>=</span><span style=color:#f60>1024</span>)
result_sim <span style=color:#555>=</span> job_sim<span style=color:#555>.</span>result()
counts <span style=color:#555>=</span> result_sim<span style=color:#555>.</span>get_counts(qc)
</code></pre></div><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>from</span> <span style=color:#0cf;font-weight:700>qiskit.visualization</span> <span style=color:#069;font-weight:700>import</span> plot_histogram
plot_histogram(counts)
</code></pre></div><p><img src=/n-blog/figures/2020-06-18-Deutsch_files/2020-06-18-Deutsch_22_0.svg alt=Circuit></p><h3 id=431-running-on-ibmq>4.3.1) Running on IBMQ</h3><p>We will choose the least busy backend with at least 2 qubits:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>from</span> <span style=color:#0cf;font-weight:700>qiskit</span> <span style=color:#069;font-weight:700>import</span> IBMQ
<span style=color:#069;font-weight:700>from</span> <span style=color:#0cf;font-weight:700>qiskit.providers.ibmq</span> <span style=color:#069;font-weight:700>import</span> least_busy

provider <span style=color:#555>=</span> IBMQ<span style=color:#555>.</span>load_account();
num_qubits <span style=color:#555>=</span> <span style=color:#f60>2</span>

backend <span style=color:#555>=</span> least_busy(provider<span style=color:#555>.</span>backends(filters<span style=color:#555>=</span><span style=color:#069;font-weight:700>lambda</span> x: x<span style=color:#555>.</span>configuration()<span style=color:#555>.</span>n_qubits <span style=color:#555>&gt;=</span> num_qubits <span style=color:#000;font-weight:700>and</span> <span style=color:#000;font-weight:700>not</span> x<span style=color:#555>.</span>configuration()<span style=color:#555>.</span>simulator <span style=color:#000;font-weight:700>and</span> x<span style=color:#555>.</span>status()<span style=color:#555>.</span>operational<span style=color:#555>==</span>True))
backend

</code></pre></div><pre><code>&lt;IBMQBackend('ibmq_burlington') from IBMQ(hub='ibm-q', group='open', project='main')&gt;
</code></pre><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>

Submiting the job for the IBM Q platform


```python
from qiskit.tools.monitor import job_monitor

job_exp = qsk.execute(qc, backend=backend)
job_monitor(job_exp)
</code></pre></div><pre><code>Job Status: job has successfully run
</code></pre><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>result_exp <span style=color:#555>=</span> job_exp<span style=color:#555>.</span>result()
</code></pre></div><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>from</span> <span style=color:#0cf;font-weight:700>qiskit.visualization</span> <span style=color:#069;font-weight:700>import</span> plot_histogram
counts_exp <span style=color:#555>=</span> result_exp<span style=color:#555>.</span>get_counts(qc)
plot_histogram([counts_exp,counts], legend<span style=color:#555>=</span>[<span style=color:#c30>&#39;Device&#39;</span>, <span style=color:#c30>&#39;Simulator&#39;</span>])
</code></pre></div><p><img src=/n-blog/figures/2020-06-18-Deutsch_files/2020-06-18-Deutsch_28_0.svg alt=Circuit></p><p>This shows that the real quantum computer has error associated with it, for this algorithm we still have the majority of states on the 1 state. This error can be mitigated by some methods, that I will show in the future.</p><h1 id=references>References</h1><p>1 - Michael A. Nielsen and Isaac L. Chuang.Quantum Computation and Quantum Information: 10th Anniversary Edition.Cambridge University Press, 2010</p><p>2 - Giuliano Benenti, Giulio Casati, and Giuliano Strini.Principles of Quantum Computation and Information. World Scientific, 2004.</p><hr><h3>Version Information</h3><table><tr><th>Qiskit Software</th><th>Version</th></tr><tr><td>Qiskit</td><td>0.19.1</td></tr><tr><td>Terra</td><td>0.14.1</td></tr><tr><td>Aer</td><td>0.5.1</td></tr><tr><td>Ignis</td><td>0.3.0</td></tr><tr><td>Aqua</td><td>0.7.0</td></tr><tr><td>IBM Q Provider</td><td>0.7.0</td></tr><tr><th>System information</th></tr><tr><td>Python</td><td>3.7.3 | packaged by conda-forge | (default, Jul 1 2019, 21:52:21)
[GCC 7.3.0]</td></tr><tr><td>OS</td><td>Linux</td></tr><tr><td>CPUs</td><td>2</td></tr><tr><td>Memory (Gb)</td><td>7.664028167724609</td></tr><tr><td colspan=2>Thu Jun 18 13:23:43 2020 -03</td></tr></table></div><footer class="post-footer clearfix"><div class=share><a class=icon-twitter href="https://twitter.com/share?text=Deutsch%20Algorithm&url=https%3a%2f%2fnahumsa.github.io%2fn-blog%2f2020-06-18-deutsch%2f" onclick="return window.open(this.href,'twitter-share','width=550,height=235'),!1" aria-label="Share on Twitter"><i class="fa fa-twitter" aria-hidden=true></i></a></div></footer></article></div></div></div><footer class=footer><div class=container><div class=site-title-wrapper><h1 class=site-title><a href=https://nahumsa.github.io/n-blog/>n-blog</a></h1><a class="button-square button-jump-top js-jump-top" href=# aria-label="Back to Top"><i class="fa fa-angle-up" aria-hidden=true></i></a></div><p class=footer-copyright><span>&copy; 2021 / Powered by <a href=https://gohugo.io/>Hugo</a></span></p><p class=footer-copyright><span><a href=https://github.com/roryg/ghostwriter>Ghostwriter theme</a> By <a href=http://jollygoodthemes.com>JollyGoodThemes</a></span>
<span>/ <a href=https://github.com/jbub/ghostwriter>Ported</a> to Hugo By <a href=https://github.com/jbub>jbub</a></span></p></div></footer><script src=https://nahumsa.github.io/n-blog/js/jquery-1.11.3.min.js></script><script src=https://nahumsa.github.io/n-blog/js/jquery.fitvids.js></script><script src=https://nahumsa.github.io/n-blog/js/scripts.js></script></body></html>