<!doctype html><html prefix="og: http://ogp.me/ns#"><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Introduction to IBM Qiskit</title><meta name=description content="First steps into Quantum Computing %matplotlib inline import qiskit as qsk import numpy as np import matplotlib.pyplot as plt 1) Introduction Qiskit is an open-source library for quantum computing developed by IBM, you can register for free on IBMQ and get access to real quantum computers.
In this post I will introduce some important functions to use IBM qiskit, this will be done by an example of constructing an entangled state, which is a important state in quantum mechanics."><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=generator content="Hugo 0.83.1"><meta name=robots content="index,follow"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="Introduction to IBM Qiskit"><meta property="og:description" content="First steps into Quantum Computing %matplotlib inline import qiskit as qsk import numpy as np import matplotlib.pyplot as plt 1) Introduction Qiskit is an open-source library for quantum computing developed by IBM, you can register for free on IBMQ and get access to real quantum computers.
In this post I will introduce some important functions to use IBM qiskit, this will be done by an example of constructing an entangled state, which is a important state in quantum mechanics."><meta property="og:type" content="article"><meta property="og:url" content="https://nahumsa.github.io/n-blog/2020-06-08-introduction-qiskit/"><link rel=stylesheet href=https://nahumsa.github.io/n-blog/dist/site.css><link rel=stylesheet href=https://nahumsa.github.io/n-blog/dist/syntax.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,400,600,700,300&subset=latin,cyrillic-ext,latin-ext,cyrillic"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous><link rel="shortcut icon" type=image/jpg href=https://nahumsa.github.io/n-blog/favicon.ico><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}},window.addEventListener('load',a=>{document.querySelectorAll("mjx-container").forEach(function(a){a.parentElement.classList+='has-jax'})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-170504520-1','auto'),ga('send','pageview'))</script><div id=wrapper><header class=site-header><div class=container><div class=site-title-wrapper><h1 class=site-title><a href=https://nahumsa.github.io/n-blog/>n-blog</a></h1><a class="button-square button-social hint--top" data-hint=Twitter aria-label=Twitter href=https://twitter.com/sa_nahum rel=me><i class="fa fa-twitter" aria-hidden=true></i></a>
<a class="button-square button-social hint--top" data-hint=Github aria-label=Github href=https://github.com/nahumsa rel=me><i class="fa fa-github-alt" aria-hidden=true></i></a>
<a class="button-square button-social hint--top" data-hint=Email aria-label="Send an Email" href=mailto:nahumsa@cbpf.br><i class="fa fa-envelope" aria-hidden=true></i></a></div><ul class=site-nav></ul></div></header><div id=container><div class=container><article class=post-container itemscope itemtype=http://schema.org/BlogPosting><header class=post-header><h1 class=post-title itemprop="name headline">Introduction to IBM Qiskit</h1><p class="post-date post-line"><span>Published <time datetime=2020-06-09 itemprop=datePublished>Tue, Jun 9, 2020</time></span>
<span>by</span>
<span itemscope itemprop=author itemtype=https://schema.org/Person><span itemprop=name><a href=# itemprop=url rel=author>Nahum SÃ¡</a></span></span></p></header><div class="post-content clearfix" itemprop=articleBody><h1 id=first-steps-into-quantum-computing>First steps into Quantum Computing</h1><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#555>%</span>matplotlib inline
<span style=color:#069;font-weight:700>import</span> <span style=color:#0cf;font-weight:700>qiskit</span> <span style=color:#069;font-weight:700>as</span> <span style=color:#0cf;font-weight:700>qsk</span>
<span style=color:#069;font-weight:700>import</span> <span style=color:#0cf;font-weight:700>numpy</span> <span style=color:#069;font-weight:700>as</span> <span style=color:#0cf;font-weight:700>np</span>
<span style=color:#069;font-weight:700>import</span> <span style=color:#0cf;font-weight:700>matplotlib.pyplot</span> <span style=color:#069;font-weight:700>as</span> <span style=color:#0cf;font-weight:700>plt</span>
</code></pre></div><h1 id=1-introduction>1) Introduction</h1><p><a href=https://qiskit.org/>Qiskit</a> is an open-source library for quantum computing developed by IBM, you can register for free on
<a href=https://quantum-computing.ibm.com/ target=_blank>IBMQ</a> and get access to real quantum computers.</p><p>In this post I will introduce some important functions to use IBM qiskit, this will be done by an example of constructing an entangled state, which is a important state in quantum mechanics.</p><h1 id=2-building-a-entangled-stated-from-scratch>2) Building a entangled stated from scratch</h1><p>We want to build a Bell State from a state $\left| 00 \right>$ and the final state is:</p><p>$$
\left| \psi \right> = \frac{\left| 00 \right> - \left| 11 \right>}{\sqrt 2}
$$</p><p>There are many gates, for reference see the <a href=https://qiskit.org/textbook/ch-states/single-qubit-gates.html>qiskit book</a>. The gates that we will use are:</p><ul><li>Pauli X: This is an one qubit gate that is represented on the computational basis by:</li></ul><p>$$
X = \frac{1}{\sqrt2}
\begin{pmatrix}
0 & 1 \\<br>1 & 0 \\<br>\end{pmatrix}
$$</p><ul><li>Hadamard: This is an one qubit gate that is represented on the computational basis by:</li></ul><p>$$
H = \frac{1}{\sqrt2}
\begin{pmatrix}
1 & 1 \\<br>1 & -1 \\<br>\end{pmatrix}
$$</p><ul><li>$C_x$(Controlled X): This is a two qubit gate that changes the second qubit if the first qubit is on the state $\left| 1 \right>$. On the computational basis is represented by:</li></ul><p>$$
C_x =
\begin{pmatrix}
1 & 0 & 0 & 0 \\<br>0 & 1 & 0 & 0 \\<br>0 & 0 & 0 & 1 \\<br>0 & 0 & 1 & 0 \\<br>\end{pmatrix}
$$</p><h2 id=21-initializing-quantum-circuits>2.1) Initializing quantum circuits</h2><p>In qiskit there are many ways to initialize a quantum circuit, the easiest one is using the <code>QuantumCircuit</code> module on qiskit, this takes two arguments <code>qregisters</code> that can be a <code>QuantumRegister</code> or an int that designates how many quantum wires you want on your circuit, the other argument is <code>cregisters</code> that can be a <code>ClassicalRegister</code> or an int that designates how many classical wires you want on your circuit. An optional argument is the <code>Name</code> that will put a name on your circuit.</p><p>I usually recommend starting using <code>QuantumRegister</code> and <code>ClassicalRegister</code> to build circuits, because this will modularize your code moving forward.</p><p>In order to see what you are doing, you can use the method <code>draw</code> inside <code>QuantumCircuit</code>, to make an image you use the &lsquo;mpl&rsquo; argument inside the method.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>qreg <span style=color:#555>=</span> qsk<span style=color:#555>.</span>QuantumRegister(<span style=color:#f60>2</span>, name<span style=color:#555>=</span><span style=color:#c30>&#39;q&#39;</span>)
circ <span style=color:#555>=</span> qsk<span style=color:#555>.</span>QuantumCircuit(qreg)
circ<span style=color:#555>.</span>draw(<span style=color:#c30>&#39;mpl&#39;</span>)
</code></pre></div><p><img src=/n-blog/figures/09-06-2020-Introduction-Qiskit_files/09-06-2020-Introduction-Qiskit_5_0.svg alt=Circuit></p><h2 id=22-adding-gates>2.2) Adding Gates</h2><p>The main gates are methods inside you <code>QuantumCircuit</code>, thus if you want to add them you should only use .nameofthegate , in the introduction section there is a link to all gates on qiskit.</p><p>Since this is the first example, I shall use linear algebra to show what is happening when you use those gates to construct our entangled state.</p><p>All circuits on qiskit starts on the state $\left| 0 \right> = \begin{pmatrix} 1 \\ 0 \end{pmatrix}$ our first opperation is to transform the $\left| 0 \right>$ state into $\left| 1 \right>$ state, this is done by the Pauli X gate:</p><p>$$
X \left| 0 \right> = \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix} \cdot \begin{pmatrix} 1 \\ 0 \end{pmatrix} = \begin{pmatrix} 0 \\ 1 \end{pmatrix} = \left| 1 \right>
$$</p><p>Thus we apply the X gate on the first register, this is done by assigning the gate to the position <code>0</code> of the QuantumRegister.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>circ<span style=color:#555>.</span>x(qreg[<span style=color:#f60>0</span>]); <span style=color:#09f;font-style:italic>#Add x on 0</span>
circ<span style=color:#555>.</span>draw(<span style=color:#c30>&#39;mpl&#39;</span>)
</code></pre></div><p><img src=/n-blog/figures/09-06-2020-Introduction-Qiskit_files/09-06-2020-Introduction-Qiskit_7_0.svg alt=Circuit></p><p>Now we apply the Haddamard gate on the first register, since the register is already on $\left| 1 \right>$ we have:</p><p>$$
H \left| 1 \right> = \begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix} \cdot \begin{pmatrix} 0 \\ 1 \end{pmatrix} = \begin{pmatrix} 1 \\ -1 \end{pmatrix} = \frac{1}{\sqrt{2}} \bigg( \left| 0 \right> - \left| 1 \right> \bigg)
$$</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>circ<span style=color:#555>.</span>h(qreg[<span style=color:#f60>0</span>]); <span style=color:#09f;font-style:italic>#Add x on 0</span>
circ<span style=color:#555>.</span>draw(<span style=color:#c30>&#39;mpl&#39;</span>)
</code></pre></div><p><img src=/n-blog/figures/09-06-2020-Introduction-Qiskit_files/09-06-2020-Introduction-Qiskit_9_0.svg alt=Circuit></p><p>In order to have an entangled state we shall use a gate that works on two qubits, this is done by the CNOT gate (also known as C-X), this will entangle the first and second qubit. It is important to note that now we have $$2^2 = 4$$ states (because we are working with two qubits). The CNOT works in this manner:</p><p>$$
C_x \left| a \right>\left| b \right> = \left| a \right>\left| a \oplus b \right>
$$</p><p>where $\oplus$ means bitwise sum.</p><p>$$
C_x \frac{1}{\sqrt{2}} \bigg( \left| 0 \right> - \left| 1 \right> \bigg)\left| 0 \right> = \frac{1}{\sqrt{2}} \bigg( \left| 0 \right>\left| 0 \oplus 0 \right> - \left| 1 \right>\left| 1 \oplus 0 \right> \bigg) = \frac{1}{\sqrt{2}} \bigg( \left| 00 \right> - \left| 11 \right> \bigg)
$$</p><p>That is exactly what we wanted.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>circ<span style=color:#555>.</span>cx(qreg[<span style=color:#f60>0</span>], qreg[<span style=color:#f60>1</span>]); <span style=color:#09f;font-style:italic>#Add CNOT on 0 and 1</span>
circ<span style=color:#555>.</span>draw(output<span style=color:#555>=</span><span style=color:#c30>&#39;mpl&#39;</span>)
</code></pre></div><p><img src=/n-blog/figures/09-06-2020-Introduction-Qiskit_files/09-06-2020-Introduction-Qiskit_11_0.svg alt=Circuit></p><h2 id=23-running-a-simulation-of-our-circuit-locally>2.3) Running a simulation of our circuit locally</h2><p>There are several ways to run your circuits, you can run them locally or remotely on a real Quantum Computer. Now I will explain how to run it locall.</p><p>For a local simulation, we will use <code>qiskit.Aer</code> which is a high performance simulator that uses C++ simulator backends. We choose backend to run our circuit depending on what we need, here are some examples of backends:</p><ul><li><p>qasm_simulator: Runs the circuit just as the actual circuit on a quantum computer is run, therefore you need to measure the qubits at the end.</p></li><li><p>statevector_simulator: Outputs the state on an ideal quantum circuit.</p></li><li><p>unitary_simulator: Outputs the unitary operator of the given circuit.</p></li><li><p>pulse_simulator: Simulates a pulse schedule for the circuit.</p></li></ul><h3 id=231-statevector_simulator>2.3.1) statevector_simulator</h3><p>In this example we chose to run on the statevector_simulator in order to see if our circuit outputs exactly our desired state. Firstly, we chose the backend and then submit the job for the chosen backend using <code>qiskit.execute</code>. Lastly, we retrieve the job by calling <code>job.result()</code></p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>backend <span style=color:#555>=</span> qsk<span style=color:#555>.</span>Aer<span style=color:#555>.</span>get_backend(<span style=color:#c30>&#39;statevector_simulator&#39;</span>)
job <span style=color:#555>=</span> qsk<span style=color:#555>.</span>execute(circ, backend)
result <span style=color:#555>=</span> job<span style=color:#555>.</span>result()
</code></pre></div><p>Let&rsquo;s print our result:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>outputstate <span style=color:#555>=</span> result<span style=color:#555>.</span>get_statevector(circ, decimals<span style=color:#555>=</span><span style=color:#f60>3</span>)
<span style=color:#069;font-weight:700>print</span>(outputstate)
</code></pre></div><pre><code>[ 0.707-0.j  0.   +0.j  0.   +0.j -0.707+0.j]
</code></pre><p>We can also visualize our result by plotting the <a href=https://en.wikipedia.org/wiki/Density_matrix>density matrix</a> of our state, this is done by taking the outer product of our state.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>from</span> <span style=color:#0cf;font-weight:700>qiskit.visualization</span> <span style=color:#069;font-weight:700>import</span> plot_state_city
plot_state_city(outputstate)
</code></pre></div><p><img src=/n-blog/figures/09-06-2020-Introduction-Qiskit_files/09-06-2020-Introduction-Qiskit_18_0.svg alt=Circuit></p><h3 id=232-qasm_simullator>2.3.2) qasm_simullator</h3><p>The previous simulation is a theoretical realization of our circuit, but when you are working with a real quantum computer you have to measure your qubits in order to get your results. This will cause the qubits to colapse to bits and we can acces them.</p><p>So we need to add the measurments on our circuits, this is done by adding a <code>ClassicalRegister</code> to our circuit.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>creg <span style=color:#555>=</span> qsk<span style=color:#555>.</span>ClassicalRegister(<span style=color:#f60>2</span>, name<span style=color:#555>=</span><span style=color:#c30>&#39;c&#39;</span>)
circ<span style=color:#555>.</span>add_register(creg)
circ<span style=color:#555>.</span>draw(<span style=color:#c30>&#39;mpl&#39;</span>)
</code></pre></div><p><img src=/n-blog/figures/09-06-2020-Introduction-Qiskit_files/09-06-2020-Introduction-Qiskit_20_0.svg alt=Circuit></p><p>We map the measurment from our quantum qubits to our classical bits.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>circ<span style=color:#555>.</span>measure(qreg,creg)
circ<span style=color:#555>.</span>draw(<span style=color:#c30>&#39;mpl&#39;</span>)
</code></pre></div><p><img src=/n-blog/figures/09-06-2020-Introduction-Qiskit_files/09-06-2020-Introduction-Qiskit_22_0.svg alt=Circuit></p><p>Now we can simulate a real quantum computer using qasm_simulator, we need to define how many times our circuit will run, this is called &ldquo;shots&rdquo;, here we chose 1024 times.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>backend_sim <span style=color:#555>=</span> qsk<span style=color:#555>.</span>Aer<span style=color:#555>.</span>get_backend(<span style=color:#c30>&#39;qasm_simulator&#39;</span>)
job_sim <span style=color:#555>=</span> qsk<span style=color:#555>.</span>execute(circ, backend_sim, shots<span style=color:#555>=</span><span style=color:#f60>1024</span>)
result_sim <span style=color:#555>=</span> job_sim<span style=color:#555>.</span>result()
</code></pre></div><p>To acces the count of our state, we use the .get_counts(circ) that will give us a dictionary with the count of each state.</p><p>The best way to visualize this result is using a histogram that will output the probability associated with each state</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>counts <span style=color:#555>=</span> result_sim<span style=color:#555>.</span>get_counts(circ)
<span style=color:#069;font-weight:700>print</span>(counts)
</code></pre></div><pre><code>{'00': 532, '11': 492}
</code></pre><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>from</span> <span style=color:#0cf;font-weight:700>qiskit.visualization</span> <span style=color:#069;font-weight:700>import</span> plot_histogram
plot_histogram(counts)
</code></pre></div><p><img src=/n-blog/figures/09-06-2020-Introduction-Qiskit_files/09-06-2020-Introduction-Qiskit_27_0.svg alt=Circuit></p><p>Therefore, we have approximately 50% shots on each state. This is exactly what we expected for the bell state.</p><p>Note that by this method we cannot know the phase associated with each state, therefore we don&rsquo;t know if our state is any specific bell state, we only know that there are only &lsquo;00&rsquo; and &lsquo;11&rsquo; qubits on our state.</p><p>To get the exact state, we need to do <a href=https://en.wikipedia.org/wiki/Quantum_tomography>Quantum State Tomography</a>, which I will talk about it in the future.</p><h2 id=24-runing-the-circuit-on-a-real-quantum-computer>2.4) Runing the circuit on a real Quantum Computer</h2><p>In order to acces the IBM Q, you will need to <a href=https://quantum-computing.ibm.com/>register</a> and copy the Token from you profile. Here the token is on a <code>.txt</code> file in order to the token remain private on the code.</p><p>You only need to register your account on your computer once using <code>save_account</code>, after this you can get acces your account using <code>load_account</code>.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>from</span> <span style=color:#0cf;font-weight:700>qiskit</span> <span style=color:#069;font-weight:700>import</span> IBMQ
token <span style=color:#555>=</span> np<span style=color:#555>.</span>loadtxt(<span style=color:#c30>&#34;Token.txt&#34;</span>, unpack<span style=color:#555>=</span>True, dtype<span style=color:#555>=</span><span style=color:#366>str</span>)
IBMQ<span style=color:#555>.</span>save_account(token, overwrite<span style=color:#555>=</span>True)
</code></pre></div><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>provider <span style=color:#555>=</span> IBMQ<span style=color:#555>.</span>load_account();
</code></pre></div><p>There are several devices that we can access by registering to IBMQ, let&rsquo;s see which ones are available to us.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>backend_list <span style=color:#555>=</span> provider<span style=color:#555>.</span>backends()
<span style=color:#069;font-weight:700>for</span> i <span style=color:#000;font-weight:700>in</span> backend_list:
    <span style=color:#069;font-weight:700>print</span>(f<span style=color:#c30>&#39;{i} </span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#39;</span>)
</code></pre></div><pre><code>ibmq_qasm_simulator 

ibmqx2 

ibmq_16_melbourne 

ibmq_vigo 

ibmq_ourense 

ibmq_london 

ibmq_burlington 

ibmq_essex 

ibmq_armonk 

ibmq_rome 
</code></pre><p>Let&rsquo;s choose the least busy device that has at least 2 qubits.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>from</span> <span style=color:#0cf;font-weight:700>qiskit.providers.ibmq</span> <span style=color:#069;font-weight:700>import</span> least_busy

num_qubits <span style=color:#555>=</span> <span style=color:#f60>2</span>

backend <span style=color:#555>=</span> least_busy(provider<span style=color:#555>.</span>backends(filters<span style=color:#555>=</span><span style=color:#069;font-weight:700>lambda</span> x: x<span style=color:#555>.</span>configuration()<span style=color:#555>.</span>n_qubits <span style=color:#555>&gt;=</span> num_qubits <span style=color:#000;font-weight:700>and</span> <span style=color:#000;font-weight:700>not</span> x<span style=color:#555>.</span>configuration()<span style=color:#555>.</span>simulator <span style=color:#000;font-weight:700>and</span> x<span style=color:#555>.</span>status()<span style=color:#555>.</span>operational<span style=color:#555>==</span>True))
backend

</code></pre></div><pre><code>&lt;IBMQBackend('ibmqx2') from IBMQ(hub='ibm-q', group='open', project='main')&gt;
</code></pre><p>Now we submit our job for the IBM Q platform, and monitor it by using the function <code>job_monitor</code></p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>from</span> <span style=color:#0cf;font-weight:700>qiskit.tools.monitor</span> <span style=color:#069;font-weight:700>import</span> job_monitor

job_exp <span style=color:#555>=</span> qsk<span style=color:#555>.</span>execute(circ, backend<span style=color:#555>=</span>backend)
job_monitor(job_exp)
</code></pre></div><pre><code>Job Status: job has successfully run
</code></pre><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>result_exp <span style=color:#555>=</span> job_exp<span style=color:#555>.</span>result()
</code></pre></div><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>from</span> <span style=color:#0cf;font-weight:700>qiskit.visualization</span> <span style=color:#069;font-weight:700>import</span> plot_histogram
counts_exp <span style=color:#555>=</span> result_exp<span style=color:#555>.</span>get_counts(circ)
plot_histogram([counts_exp,counts], legend<span style=color:#555>=</span>[<span style=color:#c30>&#39;Device&#39;</span>, <span style=color:#c30>&#39;Simulator&#39;</span>])
</code></pre></div><p><img src=/n-blog/figures/09-06-2020-Introduction-Qiskit_files/09-06-2020-Introduction-Qiskit_39_0.svg alt=Circuit></p><p>We can see that on our simulator everything is perfect, but when running on a real device there are several errors that occurs when running your circuit. I will explain some ways to correct those errors using linear algebra on other notebooks.</p><h2 id=24-retriving-older-jobs>2.4) Retriving older jobs</h2><p>If you want to retrieve older jobs after closing your code you need your job_id</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>job_id <span style=color:#555>=</span> job_exp<span style=color:#555>.</span>job_id()

<span style=color:#069;font-weight:700>print</span>(<span style=color:#c30>&#39;JOB ID: {}&#39;</span><span style=color:#555>.</span>format(job_id))
</code></pre></div><pre><code>JOB ID: 5ee007e341d47c001309221f
</code></pre><p>To acces your old job, you need to be in the same backend</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>retrieved_job <span style=color:#555>=</span> backend<span style=color:#555>.</span>retrieve_job(job_id)
</code></pre></div><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>retrieved_job<span style=color:#555>.</span>result()<span style=color:#555>.</span>get_counts(circ)
</code></pre></div><pre><code>{'01': 17, '10': 9, '00': 533, '11': 465}
</code></pre><hr><p>The code for this post is on <a href=https://github.com/nahumsa/Introduction-to-IBM_Qiskit/blob/master/Notebooks/%20Initial_Tutorial.ipynb>github</a></p><hr><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#069;font-weight:700>from</span> <span style=color:#0cf;font-weight:700>qiskit.tools.jupyter</span> <span style=color:#069;font-weight:700>import</span> <span style=color:#555>*</span>
<span style=color:#555>%</span>qiskit_version_table
</code></pre></div><h3>Version Information</h3><table><tr><th>Qiskit Software</th><th>Version</th></tr><tr><td>Qiskit</td><td>0.19.1</td></tr><tr><td>Terra</td><td>0.14.1</td></tr><tr><td>Aer</td><td>0.5.1</td></tr><tr><td>Ignis</td><td>0.3.0</td></tr><tr><td>Aqua</td><td>0.7.0</td></tr><tr><td>IBM Q Provider</td><td>0.7.0</td></tr><tr><th>System information</th></tr><tr><td>Python</td><td>3.7.3 | packaged by conda-forge | (default, Jul 1 2019, 21:52:21)
[GCC 7.3.0]</td></tr><tr><td>OS</td><td>Linux</td></tr><tr><td>CPUs</td><td>2</td></tr><tr><td>Memory (Gb)</td><td>7.664028167724609</td></tr><tr><td colspan=2>Tue Jun 09 19:08:19 2020 -03</td></tr></table></div><footer class="post-footer clearfix"><div class=share><a class=icon-twitter href="https://twitter.com/share?text=Introduction%20to%20IBM%20Qiskit&url=https%3a%2f%2fnahumsa.github.io%2fn-blog%2f2020-06-08-introduction-qiskit%2f" onclick="return window.open(this.href,'twitter-share','width=550,height=235'),!1" aria-label="Share on Twitter"><i class="fa fa-twitter" aria-hidden=true></i></a></div></footer></article></div></div></div><footer class=footer><div class=container><div class=site-title-wrapper><h1 class=site-title><a href=https://nahumsa.github.io/n-blog/>n-blog</a></h1><a class="button-square button-jump-top js-jump-top" href=# aria-label="Back to Top"><i class="fa fa-angle-up" aria-hidden=true></i></a></div><p class=footer-copyright><span>&copy; 2021 / Powered by <a href=https://gohugo.io/>Hugo</a></span></p><p class=footer-copyright><span><a href=https://github.com/roryg/ghostwriter>Ghostwriter theme</a> By <a href=http://jollygoodthemes.com>JollyGoodThemes</a></span>
<span>/ <a href=https://github.com/jbub/ghostwriter>Ported</a> to Hugo By <a href=https://github.com/jbub>jbub</a></span></p></div></footer><script src=https://nahumsa.github.io/n-blog/js/jquery-1.11.3.min.js></script><script src=https://nahumsa.github.io/n-blog/js/jquery.fitvids.js></script><script src=https://nahumsa.github.io/n-blog/js/scripts.js></script></body></html>